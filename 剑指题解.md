# 剑指题解

## 2020/7/27

#### [剑指 Offer 10- II. 青蛙跳台阶问题](https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)

难度简单47收藏分享切换为英文关注反馈

一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 `n` 级的台阶总共有多少种跳法。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

**示例 1：**

```
输入：n = 2
输出：2
```

**示例 2：**

```
输入：n = 7
输出：21
```

**提示：**

- `0 <= n <= 100`

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：36.3 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    public int numWays(int n) {
        if(n==0)return 1;
        if(n<=2) return n;
        int pre2=1,pre1=2;
        for(int i=3;i<=n;i++){
            int temp=pre1+pre2;
            if(temp>1000000007){
                temp=temp%1000000007;
            }
            pre2=pre1;
            pre1=temp;
        }
        return pre1;
    }
}
```

#### [剑指 Offer 11. 旋转数组的最小数字](https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/)

###### 二分法未作出(想到了，写不出来)

难度简单125收藏分享切换为英文关注反馈

把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 `[3,4,5,1,2]` 为 `[1,2,3,4,5]` 的一个旋转，该数组的最小值为1。 

**示例 1：**

```
输入：[3,4,5,1,2]
输出：1
```

**示例 2：**

```
输入：[2,2,2,0,1]
输出：0
```

注意：本题与主站 154 题相同：https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：39.4 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    public int minArray(int[] numbers) {
      int left=0,right=numbers.length-1;
      
      while(left<right){
          int mid=left+(right-left)/2;
          if(numbers[mid]>numbers[right]){
              left=mid+1;
          }else if(numbers[mid]==numbers[right]){
              right--;
          }else{
              right=mid;
          }
      }
      return numbers[left];
    }
}
```

#### [剑指 Offer 12. 矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)

###### 未作出（StackOverFlowError)

难度中等120收藏分享切换为英文关注反馈

请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。

[["a","**b**","c","e"],
["s","**f**","**c**","s"],
["a","d","**e**","e"]]

但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。

**示例 1：**

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
```

**示例 2：**

```
输入：board = [["a","b"],["c","d"]], word = "abcd"
输出：false
```

**提示：**

- `1 <= board.length <= 200`
- `1 <= board[i].length <= 200`

注意：本题与主站 79 题相同：https://leetcode-cn.com/problems/word-search/

执行用时：6 ms, 在所有 Java 提交中击败了79.02%的用户

内存消耗：41.9 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    int[][] dir=new int[][]{{0,-1},{0,1},{1,0},{-1,0}};
    int m,n;
    int length;
    boolean[][] visited;
    public boolean exist(char[][] board, String word) {
        this.m=board.length;
        this.n=board[0].length;
        this.length=word.length();
        if(length==0)return false;
        if(m==0||n==0)return false;
        char[] c=word.toCharArray();
        visited=new boolean[m][n];
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(board[i][j]==c[0]){
                    visited[i][j]=true;
                    if(backTracking(board,i,j,c,1)){
                        return true;
                    }
                    visited[i][j]=false;
                }
                
            }
        }
        return false;
    }
    private boolean backTracking(char[][] board,int i,int j,char[] c,int coun){
        if(coun==length){
            return true;
        }
        for(int[] num:dir){
            int di=i+num[0];
            int dj=j+num[1];
            if(di>=0&&di<m&&dj>=0&&dj<n&&!visited[di][dj]&&c[coun]==board[di][dj]){
                visited[di][dj]=true;
                //此处特别记忆
                if(backTracking(board,di,dj,c,coun+1)){
                    return true;
                }
                visited[di][dj]=false;
                
            }
        }
        return false;
    }
}
```

#### [剑指 Offer 13. 机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)

###### 未作出（StackOverFlowError)

难度中等128收藏分享切换为英文关注反馈

地上有一个m行n列的方格，从坐标 `[0,0]` 到坐标 `[m-1,n-1]` 。一个机器人从坐标 `[0, 0] `的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？ 

**示例 1：**

```
输入：m = 2, n = 3, k = 1
输出：3
```

**示例 2：**

```
输入：m = 3, n = 1, k = 0
输出：1
```

**提示：**

- `1 <= n,m <= 100`
- `0 <= k <= 20`

执行用时：1 ms, 在所有 Java 提交中击败了83.33%的用户

内存消耗：36.8 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    public int movingCount(int m, int n, int k) {
        boolean[][] visited = new boolean[m][n];
        return dfs(0, 0, m, n, k, visited);
    }

    private int dfs(int i, int j, int m, int n, int k, boolean visited[][]) {
        if (i < 0 || i >= m || j < 0 || j >= n || (i/10 + i%10 + j/10 + j%10) > k || visited[i][j]) {
            return 0;
        }
        visited[i][j] = true;
        return dfs(i + 1, j, m, n, k, visited) + dfs(i - 1, j, m, n, k, visited) + 
               dfs(i, j + 1, m, n, k, visited) + dfs(i, j - 1, m, n, k, visited) + 1;
    }
}
```

## 2020/7/28

#### [剑指 Offer 14- I. 剪绳子](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/)

###### 未作出

难度中等82收藏分享切换为英文关注反馈

给你一根长度为 `n` 的绳子，请把绳子剪成整数长度的 `m` 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 `k[0],k[1]...k[m-1]` 。请问 `k[0]*k[1]*...*k[m-1]` 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

**示例 1：**

```
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1
```

**示例 2:**

```
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
```

**提示：**

- `2 <= n <= 58`

注意：本题与主站 343 题相同：https://leetcode-cn.com/problems/integer-break/

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：36.2 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    public int cuttingRope(int n) {
        if(n < 2) return 0;
        if(n == 2) return 1;
        if(n == 3) return 2;
        int[] dp =new int[n+1];
        dp[0] = 0;
        dp[1] = 1;
        dp[2] = 2;
        dp[3] = 3;
//对于绳子长度为1,2,3的情况，先单独讨论；对于长度大于等于4时，
//所设定的f[0] = 0;f[1] = 1;f[2] = 2;f[3] = 3只是为了计算大于等于4的绳子切割时所需要用的值，
//比如切割为f[1],f[2],f[3]，实际绳子长度为1,2,3时并不会取f数组里的这些数，而是提前处理了
        int max = 0;
        for(int i = 4;i<=n;i++){
            max = 0;
            for(int j = 1;j<=i/2;j++){
                int temp = dp[j] * dp[i-j];
                if(temp > max){
                    max = temp;
                }
                dp[i] = max;
            }
        }
        return dp[n];

    }
}
```

#### [剑指 Offer 14- II. 剪绳子 II](https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/)

###### 未作出

难度中等32收藏分享切换为英文关注反馈

给你一根长度为 `n` 的绳子，请把绳子剪成整数长度的 `m` 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 `k[0],k[1]...k[m - 1]` 。请问 `k[0]*k[1]*...*k[m - 1]` 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

 

**示例 1：**

```
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1
```

**示例 2:**

```
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
```

 

**提示：**

- `2 <= n <= 1000`

注意：本题与主站 343 题相同：https://leetcode-cn.com/problems/integer-break/

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：36.4 MB, 在所有 Java 提交中击败了100.00%的用户

```java
//贪心法
//不能用动态规划了，因为取模运算后不能再比较大小了
class Solution {
    public int cuttingRope(int n) {
        if(n<2)return 0;
        if(n==2)return 1;
        if(n==3)return 2;
        long a=1000000007;
        long temp=1;
        while(n>4){
            temp=(temp*3)%a;
            n-=3;
        }
        return (int)(n*temp%a);
    }
}
```

#### [剑指 Offer 15. 二进制中1的个数](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/)

难度简单37收藏分享切换为英文关注反馈

请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。

**示例 1：**

```
输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
```

**示例 2：**

```
输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
```

**示例 3：**

```
输入：11111111111111111111111111111101
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
```

 

注意：本题与主站 191 题相同：https://leetcode-cn.com/problems/number-of-1-bits/

执行用时：1 ms, 在所有 Java 提交中击败了99.30%的用户

内存消耗：36.9 MB, 在所有 Java 提交中击败了100.00%的用户

```java
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int count=0;
        while(n!=0){
            if((n&1)==1){
                count++;
            }
            n>>>=1;
        }
        return count;
    }
}
```

#### [剑指 Offer 16. 数值的整数次方](https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/)

难度中等52收藏分享切换为英文关注反馈

实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。

 

**示例 1:**

```
输入: 2.00000, 10
输出: 1024.00000
```

**示例 2:**

```
输入: 2.10000, 3
输出: 9.26100
```

**示例 3:**

```
输入: 2.00000, -2
输出: 0.25000
解释: 2-2 = 1/22 = 1/4 = 0.25
```

 

**说明:**

- -100.0 < *x* < 100.0
- *n* 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。

注意：本题与主站 50 题相同：https://leetcode-cn.com/problems/powx-n/

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：36.7 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    
    public double myPow(double x, int n) {
         if(n == 0) return 1;
         if(x==0) return 0;
        if(n == 1) return x;
        if(n == -1) return 1 / x;
        double half = myPow(x, n / 2);
        double mod = myPow(x, n % 2);
        return half * half * mod;
    }
}
```

#### [剑指 Offer 17. 打印从1到最大的n位数](https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/)

难度简单38收藏分享切换为英文关注反馈

输入数字 `n`，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。

**示例 1:**

```
输入: n = 1
输出: [1,2,3,4,5,6,7,8,9]
```

 

说明：

- 用返回一个整数列表来代替打印
- n 为正整数

执行用时：1 ms, 在所有 Java 提交中击败了99.99%的用户

内存消耗：47.7 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    public int[] printNumbers(int n) {
        int count=1;
        while(n>0){
            n-=1;
            count*=10;
        }
        int length=count-1;
        int[] res=new int[length];
        for(int i=0;i<length;i++){
            res[i]=i+1;
        }
        return res;
    }
}
```

#### [剑指 Offer 18. 删除链表的节点](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/)

难度简单33收藏分享切换为英文关注反馈

给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。

返回删除后的链表的头节点。

**注意：**此题对比原题有改动

**示例 1:**

```
输入: head = [4,5,1,9], val = 5
输出: [4,1,9]
解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
```

**示例 2:**

```
输入: head = [4,5,1,9], val = 1
输出: [4,5,9]
解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.
```

 

**说明：**

- 题目保证链表中节点的值互不相同
- 若使用 C 或 C++ 语言，你不需要 `free` 或 `delete` 被删除的节点

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：39.3 MB, 在所有 Java 提交中击败了100.00%的用户

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode deleteNode(ListNode head, int val) {
        ListNode res=new ListNode(-1);
        res.next=head;
        ListNode target=res;
        while(target.next.val!=val){
            target=target.next;
        }
        target.next=target.next.next;
        return res.next;
    }
}
```

#### [剑指 Offer 19. 正则表达式匹配](https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/)

###### 未作出

难度困难74收藏分享切换为英文关注反馈

请实现一个函数用来匹配包含`'. '`和`'*'`的正则表达式。模式中的字符`'.'`表示任意一个字符，而`'*'`表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串`"aaa"`与模式`"a.a"`和`"ab*ac*a"`匹配，但与`"aa.a"`和`"ab*a"`均不匹配。

**示例 1:**

```
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```

**示例 2:**

```
输入:
s = "aa"
p = "a*"
输出: true
解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
```

**示例 3:**

```
输入:
s = "ab"
p = ".*"
输出: true
解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
```

**示例 4:**

```
输入:
s = "aab"
p = "c*a*b"
输出: true
解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。
```

**示例 5:**

```
输入:
s = "mississippi"
p = "mis*is*p*."
输出: false
```

- `s` 可能为空，且只包含从 `a-z` 的小写字母。
- `p` 可能为空，且只包含从 `a-z` 的小写字母以及字符 `.` 和 `*`，无连续的 `'*'`。

注意：本题与主站 10 题相同：https://leetcode-cn.com/problems/regular-expression-matching/

执行用时：2 ms, 在所有 Java 提交中击败了99.90%的用户

内存消耗：38.2 MB, 在所有 Java 提交中击败了100.00%的用户



```java
/*解题思路
假设主串为 AA，模式串为 BB 从最后一步出发，需要关注最后进来的字符。假设 AA 的长度为 nn ，BB 的长度为 mm ，关注正则表达式 BB 的最后一个字符是谁，它有三种可能，正常字符、*∗ 和 .（点），那针对这三种情况讨论即可，如下：

如果 BB 的最后一个字符是正常字符，那就是看 A[n-1]A[n−1] 是否等于 B[m-1]B[m−1]，相等则看 A_{0..n-2}与 B_{0..m-2}B ，不等则是不能匹配，这就是子问题。

如果 BB 的最后一个字符是.，它能匹配任意字符，直接看 A_{0..n-2}与 B_{0..m-2}
如果 BB 的最后一个字符是*它代表 B[m-2]=c 可以重复0次或多次，它们是一个整体 c*c∗

情况一：A[n-1] 是 00 个 cc，BB 最后两个字符废了，能否匹配取决于 A_{0..n-1}和 B_{0..m-3}
  是否匹配
情况二：A[n-1] 是多个 cc 中的最后一个（这种情况必须 A[n-1]=c 或者 c='.，所以 AA 匹配完往前挪一个，BB 继续匹配，因为可以匹配多个，继续看 A_{0..n-2}和 B_{0..m-1}是否匹配。

转移方程
f[i][j] 代表 A 的前 i 个和 B 的前 j个能否匹配

对于前面两个情况，可以合并成一种情况 f[i][j] = f[i-1][j-1]
对于第三种情况，对于 c*c∗ 分为看和不看两种情况
不看：直接砍掉正则串的后面两个， f[i][j] = f[i][j-2]
看：正则串不动，主串前移一个，f[i][j] = f[i-1][j]
初始条件
特判：需要考虑空串空正则
空串和空正则是匹配的，f[0][0] = true
空串和非空正则，不能直接定义 true 和 false，必须要计算出来。（比如A= '' ,B=a*b*c*）
非空串和空正则必不匹配，f[1][0]=...=f[n][0]=false
非空串和非空正则，那肯定是需要计算的了。
大体上可以分为空正则和非空正则两种，空正则也是比较好处理的，对非空正则我们肯定需要计算，非空正则的三种情况，前面两种可以合并到一起讨论，第三种情况是单独一种，那么也就是分为当前位置是 *∗ 和不是 *∗ 两种情况了。*/

class Solution {
    public boolean isMatch(String A, String B) {
        int n = A.length();
        int m = B.length();
        boolean[][] f = new boolean[n + 1][m + 1];

        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= m; j++) {
                //分成空正则和非空正则两种
                if (j == 0) {
                    f[i][j] = i == 0;
                } else {
                    //非空正则分为两种情况 * 和 非*
                    if (B.charAt(j - 1) != '*') {
                        if (i > 0 && (A.charAt(i - 1) == B.charAt(j - 1) || B.charAt(j - 1) == '.')) {
                            f[i][j] = f[i - 1][j - 1];
                        }
                    } else {
                        //碰到 * 了，分为看和不看两种情况
                        //不看
                        if (j >= 2) {
                            f[i][j] |= f[i][j - 2];
                        }
                        //看
                        if (i >= 1 && j >= 2 && (A.charAt(i - 1) == B.charAt(j - 2) || B.charAt(j - 2) == '.')) {
                            f[i][j] |= f[i - 1][j];
                        }
                    }
                }
            }
        }
        return f[n][m];
    }
}

```

## 2020/7/29

#### [剑指 Offer 20. 表示数值的字符串](https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/)

###### 未作出（不知道什么样的例子才是正确的，没法做）

难度中等33收藏分享切换为英文关注反馈

请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串"+100"、"5e2"、"-123"、"3.1416"、"0123"都表示数值，但"12e"、"1a3.14"、"1.2.3"、"+-5"、"-1E-16"及"12e+5.4"都不是。

注意：本题与主站 65 题相同：https://leetcode-cn.com/problems/valid-number/

执行用时：2 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：39.7 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    public boolean isNumber(String s) {
        if(s == null || s.length() == 0){
            return false;
        }
        //标记是否遇到相应情况
        boolean numSeen = false;
        boolean dotSeen = false;
        boolean eSeen = false;
        char[] str = s.trim().toCharArray();
        for(int i = 0;i < str.length; i++){
            if(str[i] >= '0' && str[i] <= '9'){
                numSeen = true;
            }else if(str[i] == '.'){
                //.之前不能出现.或者e
                if(dotSeen || eSeen){
                    return false;
                }
                dotSeen = true;
            }else if(str[i] == 'e' || str[i] == 'E'){
                //e之前不能出现e，必须出现数
                if(eSeen || !numSeen){
                    return false;
                }
                eSeen = true;
                numSeen = false;//重置numSeen，排除123e或者123e+的情况,确保e之后也出现数
            }else if(str[i] == '-' || str[i] == '+'){
                //+-出现在0位置或者e/E的后面第一个位置才是合法的
                if(i != 0 && str[i-1] != 'e' && str[i-1] != 'E'){
                    return false;
                }
            }else{//其他不合法字符
                return false;
            }
        }
        return numSeen;
    }
}

```

#### [剑指 Offer 21. 调整数组顺序使奇数位于偶数前面](https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/)

难度简单33收藏分享切换为英文关注反馈

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。

**示例：**

```
输入：nums = [1,2,3,4]
输出：[1,3,2,4] 
注：[3,1,2,4] 也是正确的答案之一。
```

**提示：**

1. `1 <= nums.length <= 50000`
2. `1 <= nums[i] <= 10000`

执行用时：2 ms, 在所有 Java 提交中击败了99.84%的用户

内存消耗：47.8 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    public int[] exchange(int[] nums) {
        int n=nums.length;
        if(n<2)return nums;
        int i=0,j=n-1;
        while(i<j){
            while(nums[i]%2==1&&i<j){
                i++;
            }
            while(nums[j]%2==0&&j>i){
                j--;
            }
            
                int temp=nums[j];
            nums[j]=nums[i];
            nums[i]=temp;
            
            
        }
        return nums;
    }
}
```

#### [剑指 Offer 22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

难度简单64收藏分享切换为英文关注反馈

输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。

 

**示例：**

```
给定一个链表: 1->2->3->4->5, 和 k = 2.

返回链表 4->5.
```

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：37.8 MB, 在所有 Java 提交中击败了100.00%的用户

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode getKthFromEnd(ListNode head, int k) {
        ListNode nextNode=head;
        while(k>0&&nextNode!=null){
            nextNode=nextNode.next;
            k--;
        }
        if(k>0){
            return null;
        }
        ListNode cur=head;
        while(nextNode!=null){
            cur=cur.next;
            nextNode=nextNode.next;
        }
        return cur;
    }
}
```

#### [剑指 Offer 24. 反转链表](https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/)

难度简单75收藏分享切换为英文关注反馈

定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

 

**示例:**

```
输入: 1->2->3->4->5->NULL
输出: 5->4->3->2->1->NULL
```

 

**限制：**

```
0 <= 节点个数 <= 5000
```

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：39.6 MB, 在所有 Java 提交中击败了100.00%的用户

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    ListNode curNode;
    public ListNode reverseList(ListNode head) {
        if(head==null||head.next==null)return head;
        ListNode nextNode=new ListNode(head.val);
        while(head.next!=null){
           curNode=new ListNode(head.next.val);
            curNode.next=nextNode;
            nextNode=curNode;
            head=head.next;
        }
        return curNode;
    }
}
```

#### [剑指 Offer 25. 合并两个排序的链表](https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/)

难度简单37收藏分享切换为英文关注反馈

输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。

**示例1：**

```
输入：1->2->4, 1->3->4
输出：1->1->2->3->4->4
```

**限制：**

```
0 <= 链表长度 <= 1000
```

执行用时：1 ms, 在所有 Java 提交中击败了99.47%的用户

内存消耗：39.6 MB, 在所有 Java 提交中击败了100.00%的用户

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode pre1=l1;
        ListNode pre2=l2;
        ListNode res=new ListNode(-1);
        ListNode cur=res;
        while(pre1!=null||pre2!=null){
            if(pre1==null){
                while(pre2!=null){
                    cur.next=pre2;
                    cur=cur.next;
                    pre2=pre2.next;
                }
            }else if(pre2==null){
                while(pre1!=null){
                    cur.next=pre1;
                    cur=cur.next;
                    pre1=pre1.next;
                }
            }else{
                if(pre1.val>pre2.val){
                    cur.next=pre2;
                    cur=cur.next;
                    pre2=pre2.next;
                }else{
                    cur.next=pre1;
                    cur=cur.next;
                    pre1=pre1.next;
                }
            }
        }
        return res.next;
    }
}
```

#### [剑指 Offer 26. 树的子结构](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/)

###### 未作出

难度中等85收藏分享切换为英文关注反馈

输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)

B是A的子结构， 即 A中有出现和B相同的结构和节点值。

例如:
给定的树 A:

`   3  / \  4  5 / \ 1  2`
给定的树 B：

`  4  / 1`
返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。

**示例 1：**

```
输入：A = [1,2,3], B = [3,1]
输出：false
```

**示例 2：**

```
输入：A = [3,4,5,1,2], B = [4,1]
输出：true
```

**限制：**

```
0 <= 节点个数 <= 10000
```

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：41.4 MB, 在所有 Java 提交中击败了100.00%的用户

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isSubStructure(TreeNode A, TreeNode B) {
        if(A==null||B==null)return false;
        return dfs(A,B)||isSubStructure(A.left,B)||isSubStructure(A.right,B);
        
    }
    private boolean dfs(TreeNode A,TreeNode B){
        if(B==null)return true;
        if(A==null)return false;
        return A.val==B.val&&dfs(A.left,B.left)&&dfs(A.right,B.right);
    }
}
```

## 2020/7/30

#### [剑指 Offer 27. 二叉树的镜像](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/)

难度简单42收藏分享切换为英文关注反馈

请完成一个函数，输入一个二叉树，该函数输出它的镜像。

例如输入：

`   4  /  \ 2   7 / \  / \1  3 6  9`
镜像输出：

```
   4  /  \ 7   2 / \  / \9  6 3  1
```

 

**示例 1：**

```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

 

**限制：**

```
0 <= 节点个数 <= 1000
```

注意：本题与主站 226 题相同：https://leetcode-cn.com/problems/invert-binary-tree/

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：36.9 MB, 在所有 Java 提交中击败了84.97%的用户

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode mirrorTree(TreeNode root) {
        if(root==null) return null;
        TreeNode temp=root.left;
        root.left=mirrorTree(root.right);
        root.right=mirrorTree(temp);
        return root;
    }
}
```

#### [剑指 Offer 28. 对称的二叉树](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/)

难度简单61收藏分享切换为英文关注反馈

请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

`  1  / \ 2  2 / \ / \3  4 4  3`
但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

```
  1  / \ 2  2  \  \  3   3
```

 

**示例 1：**

```
输入：root = [1,2,2,3,4,4,3]
输出：true
```

**示例 2：**

```
输入：root = [1,2,2,null,3,null,3]
输出：false
```

 

**限制：**

```
0 <= 节点个数 <= 1000
```

注意：本题与主站 101 题相同：https://leetcode-cn.com/problems/symmetric-tree/

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：38 MB, 在所有 Java 提交中击败了25.39%的用户

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root==null)return true;
        return help(root.left,root.right);
    }
    private boolean help(TreeNode left,TreeNode right){
        
        if(left==null&&right==null)return true;
        if(left==null||right==null)return false;
        return left.val==right.val&&help(left.right,right.left)&&help(left.left,right.right);
    }
}
```

#### [剑指 Offer 29. 顺时针打印矩阵](https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)

难度简单114收藏分享切换为英文关注反馈

输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。

 

**示例 1：**

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```

**示例 2：**

```
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
```

 

**限制：**

- `0 <= matrix.length <= 100`
- `0 <= matrix[i].length <= 100`

注意：本题与主站 54 题相同：https://leetcode-cn.com/problems/spiral-matrix/

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：41 MB, 在所有 Java 提交中击败了44.74%的用户

```java
class Solution {
    public int[] spiralOrder(int[][] matrix) {
        if(matrix==null||matrix.length==0||matrix[0].length==0)return new int[0];
        int m=matrix.length;
        int n=matrix[0].length;
        int len=m*n;
        int[] res=new int[len];
        dfs(matrix,res,0,0,0,m-1,n-1);
        return res;
    }
    private void dfs(int[][] matrix,int[] res,int index,int row,int col,int m,int n){
        
        if(row<m&&col<n){
            for(int j=col;j<=n;j++){
            res[index++]=matrix[row][j];
            }
            for(int i=row+1;i<=m;i++){
            res[index++]=matrix[i][n];
            }
            for(int j=n-1;j>=col;j--){
            res[index++]=matrix[m][j];
            }
            for(int i=m-1;i>row;i--){
            res[index++]=matrix[i][col];
            }
         dfs(matrix,res,index,row+1,col+1,m-1,n-1);
        }else if(row<m&&col==n){
            for(int i=row;i<=m;i++){
            res[index++]=matrix[i][col];
            }
            
            return ;
        }else if(col<n&&row==m){
            for(int j=col;j<=n;j++){
            res[index++]=matrix[row][j];
            }
            return ;
        }else if(col==n&&row==m){
            res[index++]=matrix[row][col];
            return;
        }
        
        
    }
}
```

#### [剑指 Offer 30. 包含min函数的栈](https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/)

难度简单34收藏分享切换为英文关注反馈

定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。

 

**示例:**

```
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.min();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.min();   --> 返回 -2.
```

 

**提示：**

1. 各函数的调用总次数不超过 20000 次

 

注意：本题与主站 155 题相同：https://leetcode-cn.com/problems/min-stack/

执行用时：19 ms, 在所有 Java 提交中击败了85.82%的用户

内存消耗：41.9 MB, 在所有 Java 提交中击败了21.16%的用户

```java
class MinStack {
    Stack<Integer> stack1;
    Stack<Integer> stack2;
    /** initialize your data structure here. */
    public MinStack() {
        stack1=new Stack<Integer>();
        stack2=new Stack<Integer>();
    }
    
    public void push(int x) {
        stack1.push(x);
        if(stack2.isEmpty()){
            stack2.push(x);
            return;
        }else{
            if(x>=stack2.peek()){
            stack2.push(stack2.peek());
            }else{
            stack2.push(x);
        }
        }
        
    }
    
    public void pop() {
        //if(stack1==null) return;
        stack1.pop();
        stack2.pop();
    }
    
    public int top() {
        
        return stack1.peek();
    }
    
    public int min() {
        return stack2.peek();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.min();
 */
```

#### [剑指 Offer 31. 栈的压入、弹出序列](https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/)

###### 未作出

难度中等56收藏分享切换为英文关注反馈

输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。

 

**示例 1：**

```
输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
输出：true
解释：我们可以按以下顺序执行：
push(1), push(2), push(3), push(4), pop() -> 4,
push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1
```

**示例 2：**

```
输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
输出：false
解释：1 不能在 2 之前弹出。
```

 

**提示：**

1. `0 <= pushed.length == popped.length <= 1000`
2. `0 <= pushed[i], popped[i] < 1000`
3. `pushed` 是 `popped` 的排列。

注意：本题与主站 946 题相同：https://leetcode-cn.com/problems/validate-stack-sequences/

执行用时：3 ms, 在所有 Java 提交中击败了82.02%的用户

内存消耗：39.4 MB, 在所有 Java 提交中击败了46.34%的用户

```
class Solution {
    public boolean validateStackSequences(int[] pushed, int[] popped) {
        int m=pushed.length,n=popped.length;
        if(m==0&&n==0)return true;
        if(m!=n||(m==0||n==0))return false;
        int left=0,right=0;
        Stack<Integer> stack1=new Stack<>();
        
        for(int i=0;i<m;i++){
            stack1.push(pushed[i]);
            while(right<n&&!stack1.isEmpty()&&stack1.peek()==popped[right]){
                stack1.pop();
                right++;
            }
        }
        return right==n;
    }
}
```

## 2020/7/31

#### [剑指 Offer 32 - I. 从上到下打印二叉树](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)

难度中等30收藏分享切换为英文关注反馈

从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。

 

例如:
给定二叉树: `[3,9,20,null,null,15,7]`,

```
    3
   / \
  9  20
    /  \
   15   7
```

返回：

```
[3,9,20,15,7]
```

 

**提示：**

1. `节点总数 <= 1000`

执行用时：1 ms, 在所有 Java 提交中击败了99.67%的用户

内存消耗：39.8 MB, 在所有 Java 提交中击败了59.87%的用户

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int[] levelOrder(TreeNode root) {
        List<Integer> list=new ArrayList<Integer>();
        LinkedList<TreeNode> queue=new LinkedList<TreeNode>();
        if(root==null){
            return new int[0];
        }
        queue.addFirst(root);
        list.add(root.val);
        while(queue.size()>0){
            int n=queue.size();
            while(n>0){
            TreeNode cur=queue.removeFirst();
            if(cur.left!=null){
                queue.addLast(cur.left);
                list.add(cur.left.val);
            }
            if(cur.right!=null){
                queue.addLast(cur.right);
                list.add(cur.right.val);
            }
            n--;
            }
        }
        int[] res = new int[list.size()];
        for(int i=0; i<res.length; i++) {
            res[i] = list.get(i);
        }
        return res;
    }
}
```

## 2020/8/6

#### [剑指 Offer 32 - III. 从上到下打印二叉树 III](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)

难度中等38收藏分享切换为英文关注反馈

请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。

 

例如:
给定二叉树: `[3,9,20,null,null,15,7]`,

```
    3
   / \
  9  20
    /  \
   15   7
```

返回其层次遍历结果：

```
[
  [3],
  [20,9],
  [15,7]
]
```

 

**提示：**

1. `节点总数 <= 1000`

执行用时：1 ms, 在所有 Java 提交中击败了99.72%的用户

内存消耗：40.1 MB, 在所有 Java 提交中击败了25.21%的用户

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> list=new ArrayList<>();
        LinkedList<TreeNode> queue=new LinkedList<TreeNode>();
        if(root==null) return list;
        queue.addFirst(root);
        boolean flag=true;
        while(queue.size()>0){
            int n=queue.size();
            List<Integer> temp=new ArrayList<>();
            
            while(n>0){
                TreeNode cur=queue.removeFirst();
                if(flag){
                    temp.add(cur.val);
                }else{
                    temp.add(0,cur.val);
                }
                
                TreeNode left=cur.left;
                TreeNode right=cur.right;
                if(left!=null)queue.addLast(left);
                if(right!=null)queue.addLast(right);
                n--;
                
            }
           
            list.add(new ArrayList<Integer>(temp));
            flag=!flag;
            
        }
        return list;
    }
}
```

#### [剑指 Offer 33. 二叉搜索树的后序遍历序列](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)

难度中等89收藏分享切换为英文关注反馈

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 `true`，否则返回 `false`。假设输入的数组的任意两个数字都互不相同。

 

参考以下这颗二叉搜索树：

```
     5
    / \
   2   6
  / \
 1   3
```

**示例 1：**

```
输入: [1,6,3,2,5]
输出: false
```

**示例 2：**

```
输入: [1,3,2,6,5]
输出: true
```

 

**提示：**

1. `数组长度 <= 1000`

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：37.1 MB, 在所有 Java 提交中击败了54.16%的用户

```java
class Solution {
    int[] postorder;
    public boolean verifyPostorder(int[] postorder) {
        this.postorder=postorder;
        int n=postorder.length;
        if(n==0||n==1)return true;
        return help(0,n-1);
    }
    private boolean help(int left,int n){
        if(left>=n){
            return true;
        }
        int root=postorder[n];
        int i=left,j=0;
        while(i<n){
            if(postorder[i]>root){
                break;
            }
            i++;
        }
        j=i;
        while(i<n){
            if(postorder[i]<root){
                return false;
            }
            i++;
        }
        return help(left,j-1)&&help(j,n-1);
    }
}
```

#### [剑指 Offer 34. 二叉树中和为某一值的路径](https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/)

难度中等68收藏分享切换为英文关注反馈

输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。

 

**示例:**
给定如下二叉树，以及目标和 `sum = 22`，

```
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
```

返回:

```
[
   [5,4,11,2],
   [5,8,4,5]
]
```

 

**提示：**

1. `节点总数 <= 10000`

注意：本题与主站 113 题相同：https://leetcode-cn.com/problems/path-sum-ii/

执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：40.4 MB, 在所有 Java 提交中击败了13.33%的用户

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    List<List<Integer>> res=new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int sum) {
        if(root==null)return res;
        backTracing(root,sum,new ArrayList<>());
        return res;
    }
    private void backTracing(TreeNode root,int sum,List<Integer> list){
        
        if(root==null){
            return;
        }
        int cur=sum-root.val;
        if(cur==0&&root.left==null&&root.right==null){
            list.add(root.val);
            res.add(new ArrayList<Integer>(list));
            list.remove(list.size()-1);
        }else{
            list.add(root.val);
            backTracing(root.left,cur,list);
            backTracing(root.right,cur,list);
            list.remove(list.size()-1); 
        }
    }
}
```

#### [剑指 Offer 35. 复杂链表的复制](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/)

###### 未作出（random处）

难度中等76收藏分享切换为英文关注反馈

请实现 `copyRandomList` 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 `next` 指针指向下一个节点，还有一个 `random` 指针指向链表中的任意节点或者 `null`。

 

**示例 1：**

![img](%E5%89%91%E6%8C%87%E9%A2%98%E8%A7%A3.assets/e1.png)

```
输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
```

**示例 2：**

![img](%E5%89%91%E6%8C%87%E9%A2%98%E8%A7%A3.assets/e2.png)

```
输入：head = [[1,1],[2,1]]
输出：[[1,1],[2,1]]
```

**示例 3：**

**![img](%E5%89%91%E6%8C%87%E9%A2%98%E8%A7%A3.assets/e3.png)**

```
输入：head = [[3,null],[3,0],[3,null]]
输出：[[3,null],[3,0],[3,null]]
```

**示例 4：**

```
输入：head = []
输出：[]
解释：给定的链表为空（空指针），因此返回 null。
```

 

**提示：**

- `-10000 <= Node.val <= 10000`
- `Node.random` 为空（null）或指向链表中的节点。
- 节点数目不超过 1000 。

 

**注意：**本题与主站 138 题相同：https://leetcode-cn.com/problems/copy-list-with-random-pointer/

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：39.3 MB, 在所有 Java 提交中击败了74.71%的用户

```java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/
class Solution {
    public Node copyRandomList(Node head) {
        if (head == null) {
            return head;
        }
        // 完成链表节点的复制
        Node cur = head;
        while (cur != null) {
            Node copyNode = new Node(cur.val);
            copyNode.next = cur.next;
            cur.next = copyNode;
            cur = cur.next.next;
        }

        // 完成链表复制节点的随机指针复制
        cur = head;
        while (cur != null) {
            if (cur.random != null) { // 注意判断原来的节点有没有random指针
                cur.next.random = cur.random.next;
            }
            cur = cur.next.next;
        }

        // 将链表一分为二
        Node copyHead = head.next;
        cur = head;
        Node curCopy = head.next;
        while (cur != null) {
            cur.next = cur.next.next;
            cur = cur.next;
            if (curCopy.next != null) {
                curCopy.next = curCopy.next.next;
                curCopy = curCopy.next;
            }
        }
        return copyHead;
    }
}
```

## 2020/8/7

#### [剑指 Offer 36. 二叉搜索树与双向链表](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)

###### 未作出

难度中等86收藏分享切换为英文关注反馈

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。

 

为了让您更好地理解问题，以下面的二叉搜索树为例：

 

![img](%E5%89%91%E6%8C%87%E9%A2%98%E8%A7%A3.assets/bstdlloriginalbst.png)

 

我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。

下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。

 

![img](%E5%89%91%E6%8C%87%E9%A2%98%E8%A7%A3.assets/bstdllreturndll.png)

 

特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。

 

**注意：**本题与主站 426 题相同：https://leetcode-cn.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/

**注意：**此题对比原题有改动。

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：39.5 MB, 在所有 Java 提交中击败了29.81%的用户

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val,Node _left,Node _right) {
        val = _val;
        left = _left;
        right = _right;
    }
};
*/
class Solution {
    
    Node pre = null, head = null;  //pre记录上一个节点，head为最后返回的头结点
    
    public Node treeToDoublyList(Node root) {
        if(root == null) return root;
        helper(root);  //得到一个双向链表，head指向头结点
        head.left = pre;
        pre.right = head;  //形成循环链表
        return head;
    }
    
    public void helper(Node root){
        if(root == null) return;  //到了最后的时候，就返回
        helper(root.left);  //规整左子树
        root.left = pre;
        if(pre != null){
            pre.right = root;  //当前面还有节点的时候，连接上
        }
        else
            head = root;   //如果前面没有节点了，证明是头结点，就更新head
        pre = root;   //root可以视为一个节点了
        helper(root.right);  //规整右子树
    }
}
```

#### [剑指 Offer 37. 序列化二叉树](https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/)

###### 未作出（反序列化重构二叉树那块没写出）

难度困难57收藏分享切换为英文关注反馈

请实现两个函数，分别用来序列化和反序列化二叉树。

**示例:** 

```
你可以将以下二叉树：

    1
   / \
  2   3
     / \
    4   5

序列化为 "[1,2,3,null,null,4,5]"
```

注意：本题与主站 297 题相同：https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/

执行用时：24 ms, 在所有 Java 提交中击败了61.69%的用户

内存消耗：41.8 MB, 在所有 Java 提交中击败了62.08%的用户

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        StringBuilder sb=new StringBuilder();
        sb.append("[");
        if(root==null){
            sb.append("null]");
            return sb.toString();
        }
        LinkedList<TreeNode> queue=new LinkedList<>();
        queue.addFirst(root);
        sb.append(root.val);
        while(queue.size()>0){
            int n=queue.size();
            while(n>0){
                TreeNode cur=queue.removeFirst();
                if(cur.left!=null){
                    queue.addLast(cur.left);
                    sb.append(","+cur.left.val);
                }else{
                    sb.append(",null");
                }
                if(cur.right!=null){
                    queue.addLast(cur.right);
                    sb.append(","+cur.right.val);
                }else{
                    sb.append(",null");
                }
                n--;
            }
        }
        sb.append("]");
        return sb.toString();
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        String[] target=data.substring(1,data.length()-1).split(",");
        if(target[0].equals("null"))return null;
        TreeNode root=new TreeNode(Integer.parseInt(target[0]));
        LinkedList<TreeNode> queue=new LinkedList<>();
        queue.addFirst(root);
        int i=1;
        while(queue.size()>0){
            TreeNode cur=queue.removeFirst();
            if(!target[i].equals("null")){
                cur.left=new TreeNode(Integer.parseInt(target[i]));
                queue.addLast(cur.left);
            }
            i++;
            if(!target[i].equals("null")){
                cur.right=new TreeNode(Integer.parseInt(target[i]));
                queue.addLast(cur.right);
            }
            i++;
        }
        return root;
    }
}

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.deserialize(codec.serialize(root));
```

#### [剑指 Offer 38. 字符串的排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)

难度中等79收藏分享切换为英文关注反馈

输入一个字符串，打印出该字符串中字符的所有排列。

 

你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。

 

**示例:**

```
输入：s = "abc"
输出：["abc","acb","bac","bca","cab","cba"]
```

 

**限制：**

```
1 <= s 的长度 <= 8
```

执行用时：10 ms, 在所有 Java 提交中击败了91.29%的用户

内存消耗：44.6 MB, 在所有 Java 提交中击败了64.69%的用户

```java
class Solution {
    List<String> list=new ArrayList<>();
    int n;
    char[] matrix;
    boolean[] visited;
    public String[] permutation(String s) {
        this.matrix=s.toCharArray();
        Arrays.sort(matrix);
        this.n=matrix.length;
        visited=new boolean[n];
        backTracing(new StringBuilder(),0);
        return list.toArray(new String[list.size()]);
    }
    private void backTracing(StringBuilder sb,int count){
        if(count==n){
            //StringBuilder res=new StringBuilder(sb);
            list.add(sb.toString());
            return;
        }
        for(int i=0;i<n;i++){
            if(visited[i]){
                continue;
            }
            if(i>0&&matrix[i]==matrix[i-1]&&!visited[i-1]){
                continue;
            }
            sb.append(matrix[i]);
            //count++;
            visited[i]=true;
            backTracing(sb,count+1);
            visited[i]=false;
            //count--;
            sb.deleteCharAt(sb.length()-1);
        }
    }
}
```

## 2020/8/8

#### [剑指 Offer 41. 数据流中的中位数](https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/)

###### 未作出

难度困难50收藏分享切换为英文关注反馈

如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。

例如，

[2,3,4] 的中位数是 3

[2,3] 的中位数是 (2 + 3) / 2 = 2.5

设计一个支持以下两种操作的数据结构：

- void addNum(int num) - 从数据流中添加一个整数到数据结构中。
- double findMedian() - 返回目前所有元素的中位数。

**示例 1：**

```
输入：
["MedianFinder","addNum","addNum","findMedian","addNum","findMedian"]
[[],[1],[2],[],[3],[]]
输出：[null,null,null,1.50000,null,2.00000]
```

**示例 2：**

```
输入：
["MedianFinder","addNum","findMedian","addNum","findMedian"]
[[],[2],[],[3],[]]
输出：[null,null,2.00000,null,2.50000]
```

 

**限制：**

- 最多会对 `addNum、findMedia`进行 `50000` 次调用。

注意：本题与主站 295 题相同：https://leetcode-cn.com/problems/find-median-from-data-stream/

执行用时：72 ms, 在所有 Java 提交中击败了94.32%的用户

内存消耗：51 MB, 在所有 Java 提交中击败了49.82%的用户

```java
/* 大顶堆，存储左半边元素 */
private PriorityQueue<Integer> left = new PriorityQueue<>((o1, o2) -> o2 - o1);
/* 小顶堆，存储右半边元素，并且右半边元素都大于左半边 */
private PriorityQueue<Integer> right = new PriorityQueue<>();
/* 当前数据流读入的元素个数 */
private int N = 0;

public void Insert(Integer val) {
    /* 插入要保证两个堆存于平衡状态 */
    if (N % 2 == 0) {
        /* N 为偶数的情况下插入到右半边。
         * 因为右半边元素都要大于左半边，但是新插入的元素不一定比左半边元素来的大，
         * 因此需要先将元素插入左半边，然后利用左半边为大顶堆的特点，取出堆顶元素即为最大元素，此时插入右半边 */
        left.add(val);
        right.add(left.poll());
    } else {
        right.add(val);
        left.add(right.poll());
    }
    N++;
}

public Double GetMedian() {
    if (N % 2 == 0)
        return (left.peek() + right.peek()) / 2.0;
    else
        return (double) right.peek();
}
```

#### [剑指 Offer 42. 连续子数组的最大和](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)

难度简单100收藏分享切换为英文关注反馈

输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。

要求时间复杂度为O(n)。

 

**示例1:**

```
输入: nums = [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
```

 

**提示：**

- `1 <= arr.length <= 10^5`
- `-100 <= arr[i] <= 100`

注意：本题与主站 53 题相同：https://leetcode-cn.com/problems/maximum-subarray/

执行用时：1 ms, 在所有 Java 提交中击败了99.34%的用户

内存消耗：46.7 MB, 在所有 Java 提交中击败了16.86%的用户

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int n=nums.length;
        int max=Integer.MIN_VALUE;
        int preMax=Integer.MIN_VALUE;
        for(int i=0;i<n;i++){
            if(preMax>0){
                preMax+=nums[i];
            }else{
                preMax=nums[i];
            }
            if(preMax>max){
                max=preMax;
            }
        }
        return max;
    }
}
```

#### [剑指 Offer 43. 1～n整数中1出现的次数](https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/)

###### 未作出

难度中等74收藏分享切换为英文关注反馈

输入一个整数 `n` ，求1～n这n个整数的十进制表示中1出现的次数。

例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。

 

**示例 1：**

```
输入：n = 12
输出：5
```

**示例 2：**

```
输入：n = 13
输出：6
```

 

**限制：**

- `1 <= n < 2^31`

注意：本题与主站 233 题相同：https://leetcode-cn.com/problems/number-of-digit-one/

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：36.5 MB, 在所有 Java 提交中击败了33.40%的用户

```java
/*
首先可以先分类：

#### 个位

我们知道在个位数上，1会每隔10出现一次，例如1、11、21等等，我们发现以10为一个阶梯的话，每一个完整的阶梯里面都有一个1，例如数字22，按照10为间隔来分三个阶梯，在完整阶梯0-9，10-19之中都有一个1，但是19之后有一个不完整的阶梯，我们需要去判断这个阶梯中会不会出现1，易推断知，如果最后这个露出来的部分小于1，则不可能出现1（这个归纳换做其它数字也成立）。

我们可以归纳个位上1出现的个数为：

> **n/10 \* 1+(n%10!=0 ? 1 : 0)**

#### 十位

现在说十位数，十位数上出现1的情况应该是10-19，依然沿用分析个位数时候的阶梯理论，我们知道10-19这组数，每隔100出现一次，这次我们的阶梯是100，例如数字317，分析有阶梯0-99，100-199，200-299三段完整阶梯，每一段阶梯里面都会出现10次1（从10-19），最后分析露出来的那段不完整的阶梯。我们考虑如果露出来的数大于19，那么直接算10个1就行了，因为10-19肯定会出现；如果小于10，那么肯定不会出现十位数的1；如果在10-19之间的，我们计算结果应该是k - 10 + 1。例如我们分析300-317，17个数字，1出现的个数应该是17-10+1=8个。

那么现在可以归纳：十位上1出现的个数为：

> - 设k = n % 100，即为不完整阶梯段的数字
> - 归纳式为：**(n / 100) \* 10 + (if(k > 19) 10 else if(k < 10) 0 else k - 10 + 1)**

#### 百位

现在说百位1，我们知道在百位，100-199都会出现百位1，一共出现100次，阶梯间隔为1000，100-199这组数，每隔1000就会出现一次。这次假设我们的数为2139。跟上述思想一致，先算阶梯数 * 完整阶梯中1在百位出现的个数，即n/1000 * 100得到前两个阶梯中1的个数，那么再算漏出来的部分139，沿用上述思想，不完整阶梯数k199，得到100个百位1，100<=k<=199则得到k - 100 + 1个百位1。

那么继续归纳百位上出现1的个数：

> - 设k = n % 1000
> - 归纳式为：**(n / 1000) \* 100 + (if(k >199) 100 else if(k < 100) 0 else k - 100 + 1)**

后面的依次类推....

#### 再次回顾个位

我们把个位数上算1的个数的式子也纳入归纳式中

> - k = n % 10
> - 个位数上1的个数为：**n / 10 \* 1 + (if(k > 1) 1 else if(k < 1) 0 else k - 1 + 1)**

完美！归纳式看起来已经很规整了。 来一个更抽象的归纳，设i为计算1所在的位数，i=1表示计算个位数的1的个数，10表示计算十位数的1的个数等等。

> - k = n % (i * 10)
> - **count(i) = (n / (i \* 10)) \* i + (if(k > i \* 2 - 1) i else if(k < i) 0 else k - i + 1)**

好了，这样从10到10的n次方的归纳就完成了。
*/
class Solution {
    public int countDigitOne(int n) {
        if(n<=0)return 0;
        long count=0;
        for(long i=1;i<=n;i*=10){
            //越界
            long number=10*i;
            long k=n%number;
            long temp=0;
            if(k>i*2-1){
                temp=i;
            }else if(k<i){
                temp=0;
            }else{
                temp=k-i+1;
            }
            count+=(n/number)*i+temp;
        }
        return (int)count;
    }
}
```

## 2020/8/10

#### [剑指 Offer 44. 数字序列中某一位的数字](https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/)

###### 思路正确，但是最后差一些

难度中等52收藏分享切换为英文关注反馈

数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。

请写一个函数，求任意第n位对应的数字。

 

**示例 1：**

```
输入：n = 3
输出：3
```

**示例 2：**

```
输入：n = 11
输出：0
```

 

**限制：**

- `0 <= n < 2^31`

注意：本题与主站 400 题相同：https://leetcode-cn.com/problems/nth-digit/

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：36.6 MB, 在所有 Java 提交中击败了7.61%的用户

```java
/* 数字范围    数量  位数    占多少位
    1-9        9      1       9
    10-99      90     2       180
    100-999    900    3       2700
    1000-9999  9000   4       36000  ...

    例如 2901 = 9 + 180 + 2700 + 12 即一定是4位数,第12位   n = 12;
    数据为 = 1000 + (12 - 1)/ 4  = 1000 + 2 = 1002
    定位1002中的位置 = (n - 1) %  4 = 3    s.charAt(3) = 2;
*/
class Solution {
    public int findNthDigit(int n) {
        int digit = 1;   // n所在数字的位数
        long start = 1;  // 数字范围开始的第一个数
        long count = 9;  // 占多少位
        while(n > count){
            n -= count;
            digit++;
            start *= 10;
            count = digit * start * 9;
        }
        long num = start + (n - 1) / digit;
        return Long.toString(num).charAt((n - 1) % digit) - '0';
    }
}
```

#### [剑指 Offer 45. 把数组排成最小的数](https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/)

###### 未优化，排序算法差了些

难度中等80收藏分享切换为英文关注反馈

输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。

 

**示例 1:**

```
输入: [10,2]
输出: "102"
```

**示例 2:**

```
输入: [3,30,34,5,9]
输出: "3033459"
```

 

**提示:**

- `0 < nums.length <= 100`

**说明:**

- 输出结果可能非常大，所以你需要返回一个字符串而不是整数
- 拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0

执行用时：6 ms, 在所有 Java 提交中击败了90.29%的用户

内存消耗：39.7 MB, 在所有 Java 提交中击败了22.34%的用户

```java
class Solution {
    public String minNumber(int[] nums) {
        String[] strs = new String[nums.length];
        for(int i = 0; i < nums.length; i++)
            strs[i] = String.valueOf(nums[i]);
        fastSort(strs, 0, strs.length - 1);
        StringBuilder res = new StringBuilder();
        for(String s : strs)
            res.append(s);
        return res.toString();
    }
    void fastSort(String[] strs, int l, int r) {
        if(l >= r) return;
        int i = l, j = r;
        String tmp = strs[i];
        while(i < j) {
            while((strs[j] + strs[l]).compareTo(strs[l] + strs[j]) >= 0 && i < j) j--;
            while((strs[i] + strs[l]).compareTo(strs[l] + strs[i]) <= 0 && i < j) i++;
            tmp = strs[i];
            strs[i] = strs[j];
            strs[j] = tmp;
        }
        strs[i] = strs[l];
        strs[l] = tmp;
        fastSort(strs, l, i - 1);
        fastSort(strs, i + 1, r);
    }
}

```

#### [剑指 Offer 46. 把数字翻译成字符串](https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/)

难度中等115收藏分享切换为英文关注反馈

给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。

 

**示例 1:**

```
输入: 12258
输出: 5
解释: 12258有5种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"
```

 

**提示：**

- `0 <= num < 231`

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：36.4 MB, 在所有 Java 提交中击败了50.26%的用户

```java
class Solution {
    public int translateNum(int num) {
        String s=String.valueOf(num);
        int n=s.length();
        int[] dp=new int[n];

        dp[0]=1;
        if(n<2){
            return dp[0];
        }
        if(s.charAt(0)=='1'||(s.charAt(0)=='2'&&s.charAt(1)-'0'<6)){
            dp[1]=2;
        }else{
            dp[1]=1;
        }
        for(int i=2;i<n;i++){
            if(s.charAt(i-1)=='1'||(s.charAt(i-1)=='2'&&s.charAt(i)-'0'<6)){
                dp[i]=dp[i-1]+dp[i-2];
            }else{
                dp[i]=dp[i-1];
            }
        }
        return dp[n-1];
    }
}
```

## 2020/8/11

#### [剑指 Offer 47. 礼物的最大价值](https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/)

难度中等56收藏分享切换为英文关注反馈

在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？

 

**示例 1:**

```
输入: 
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 12
解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物
```

 

提示：

- `0 < grid.length <= 200`
- `0 < grid[0].length <= 200`

执行用时：3 ms, 在所有 Java 提交中击败了83.71%的用户

内存消耗：42.6 MB, 在所有 Java 提交中击败了30.91%的用户

```java
class Solution {
    public int maxValue(int[][] grid) {
      int m=grid.length,n=grid[0].length;
      int[][] dp=new int[m][n];
      dp[0][0]=grid[0][0];
      for(int i=1;i<n;i++){
          dp[0][i]=dp[0][i-1]+grid[0][i];
      }
      for(int i=1;i<m;i++){
          dp[i][0]=dp[i-1][0]+grid[i][0];
      }
      for(int i=1;i<m;i++){
          for(int j=1;j<n;j++){
              dp[i][j]=Math.max(dp[i][j-1],dp[i-1][j])+grid[i][j];
          }
      }
      return dp[m-1][n-1];  
    }
}
```

#### [剑指 Offer 48. 最长不含重复字符的子字符串](https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/)

难度中等69收藏分享切换为英文关注反馈

请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。

 

**示例 1:**

```
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**

```
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

 

提示：

- `s.length <= 40000`

注意：本题与主站 3 题相同：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/

执行用时：3 ms, 在所有 Java 提交中击败了98.54%的用户

内存消耗：39.7 MB, 在所有 Java 提交中击败了83.78%的用户

```java
//双指针+是否使用数组
class Solution {
    public int lengthOfLongestSubstring(String s) {
        
        int n=s.length();
        if(n<1)return 0;
        char[] res=s.toCharArray();
        boolean[] visited=new boolean[128];
        int left=0,right=1;
        visited[res[left]-' ']=true;
        int max=1;
        while(right<n){
            if(visited[res[right]-' ']){
                if(right-left>max){
                    max=right-left;
                }
                while(res[left]!=res[right]){
                    visited[res[left]-' ']=false;
                    left++;
                }
                left++;
                right++;
            }else{
                visited[res[right]-' ']=true;
                right++;
            }

        }
        if(right-left>max){
            max=right-left;
        }
        return max;
    }
}
```

#### [剑指 Offer 49. 丑数](https://leetcode-cn.com/problems/chou-shu-lcof/)

###### 未最优

难度中等56收藏分享切换为英文关注反馈

我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。

 

**示例:**

```
输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
```

**说明:** 

1. `1` 是丑数。
2. `n` **不超过**1690。

注意：本题与主站 264 题相同：https://leetcode-cn.com/problems/ugly-number-ii/

执行用时：3 ms, 在所有 Java 提交中击败了79.20%的用户

内存消耗：37.8 MB, 在所有 Java 提交中击败了41.17%的用户

```java
class Solution {
    public int nthUglyNumber(int n) {
        int p2=0,p3=0,p5=0;
        int[] dp=new int[n];
        dp[0]=1;
        for(int i=1;i<n;i++){
            dp[i]=Math.min(dp[p2]*2,Math.min(dp[p3]*3,dp[p5]*5));
            if(dp[i]==dp[p2]*2) p2++;
            if(dp[i]==dp[p3]*3) p3++;
            if(dp[i]==dp[p5]*5) p5++; 
        }
        return dp[n-1];
    }
    // 一个十分巧妙的动态规划问题
    // 1.我们将前面求得的丑数记录下来，后面的丑数就是前面的丑数*2，*3，*5
    // 2.但是问题来了，我怎么确定已知前面k-1个丑数，我怎么确定第k个丑数呢
    // 3.采取用三个指针的方法，p2,p3,p5
    // 4.index2指向的数字下一次永远*2，p3指向的数字下一次永远*3，p5指向的数字永远*5
    // 5.我们从2*p2 3*p3 5*p5选取最小的一个数字，作为第k个丑数
    // 6.如果第K个丑数==2*p2，也就是说前面0-p2个丑数*2不可能产生比第K个丑数更大的丑数了，所以p2++
    // 7.p3,p5同理
    // 8.返回第n个丑数

}

```

#### [剑指 Offer 50. 第一个只出现一次的字符](https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/)

###### 未最优

难度简单39收藏分享切换为英文关注反馈

在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。

**示例:**

```
s = "abaccdeff"
返回 "b"

s = "" 
返回 " "
```

 

**限制：**

```
0 <= s 的长度 <= 50000
```

执行用时：4 ms, 在所有 Java 提交中击败了99.36%的用户

内存消耗：40.1 MB, 在所有 Java 提交中击败了88.85%的用户

```java
class Solution {
     public char firstUniqChar(String s) {
        int[] count = new int[256];
        char[] chars = s.toCharArray();
        for(char c : chars)
            count[c]++;
        for(char c : chars){
            if(count[c] == 1)
                return c;
        }
        return ' ';
    }

}
```

## 2020/8/12

#### [剑指 Offer 51. 数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)

###### 只会暴力，未想到关键

难度困难215收藏分享切换为英文关注反馈

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。

 

**示例 1:**

```
输入: [7,5,6,4]
输出: 5
```

 

**限制：**

```
0 <= 数组长度 <= 50000
```

执行用时：37 ms, 在所有 Java 提交中击败了66.63%的用户

内存消耗：48.9 MB, 在所有 Java 提交中击败了67.23%的用户

```java
//归并排序
public class Solution {

    public int reversePairs(int[] nums) {
        int len = nums.length;

        if (len < 2) {
            return 0;
        }

        int[] copy = new int[len];
        for (int i = 0; i < len; i++) {
            copy[i] = nums[i];
        }

        int[] temp = new int[len];
        return reversePairs(copy, 0, len - 1, temp);
    }

    /**
     * nums[left..right] 计算逆序对个数并且排序
     *
     * @param nums
     * @param left
     * @param right
     * @param temp
     * @return
     */
    private int reversePairs(int[] nums, int left, int right, int[] temp) {
        if (left == right) {
            return 0;
        }

        int mid = left + (right - left) / 2;
        int leftPairs = reversePairs(nums, left, mid, temp);
        int rightPairs = reversePairs(nums, mid + 1, right, temp);

        if (nums[mid] <= nums[mid + 1]) {
            return leftPairs + rightPairs;
        }

        int crossPairs = mergeAndCount(nums, left, mid, right, temp);
        return leftPairs + rightPairs + crossPairs;
    }

    /**
     * nums[left..mid] 有序，nums[mid + 1..right] 有序
     *
     * @param nums
     * @param left
     * @param mid
     * @param right
     * @param temp
     * @return
     */
    private int mergeAndCount(int[] nums, int left, int mid, int right, int[] temp) {
        for (int i = left; i <= right; i++) {
            temp[i] = nums[i];
        }

        int i = left;
        int j = mid + 1;

        int count = 0;
        for (int k = left; k <= right; k++) {

            if (i == mid + 1) {
                nums[k] = temp[j];
                j++;
            } else if (j == right + 1) {
                nums[k] = temp[i];
                i++;
            } else if (temp[i] <= temp[j]) {
                nums[k] = temp[i];
                i++;
            } else {
                nums[k] = temp[j];
                j++;
                count += (mid - i + 1);
            }
        }
        return count;
    }
}
```

#### [剑指 Offer 52. 两个链表的第一个公共节点](https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/)

难度简单83收藏分享切换为英文关注反馈

输入两个链表，找出它们的第一个公共节点。

如下面的两个链表**：**

[![img](%E5%89%91%E6%8C%87%E9%A2%98%E8%A7%A3.assets/160_statement.png)](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

在节点 c1 开始相交。

 

**示例 1：**

[![img](%E5%89%91%E6%8C%87%E9%A2%98%E8%A7%A3.assets/160_example_1.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
```

 

**示例 2：**

[![img](%E5%89%91%E6%8C%87%E9%A2%98%E8%A7%A3.assets/160_example_2.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png)

```
输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Reference of the node with value = 2
输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
```

 

**示例 3：**

[![img](%E5%89%91%E6%8C%87%E9%A2%98%E8%A7%A3.assets/160_example_3.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png)

```
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
解释：这两个链表不相交，因此返回 null。
```

 

**注意：**

- 如果两个链表没有交点，返回 `null`.
- 在返回结果后，两个链表仍须保持原有的结构。
- 可假定整个链表结构中没有循环。
- 程序尽量满足 O(*n*) 时间复杂度，且仅用 O(*1*) 内存。
- 本题与主站 160 题相同：https://leetcode-cn.com/problems/intersection-of-two-linked-lists/

执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：42.8 MB, 在所有 Java 提交中击败了34.23%的用户

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if(headA==null||headB==null)return null;
        ListNode index1=headA;
        ListNode index2=headB;
        int count1=1,count2=1;
        while(index1!=null){
            index1=index1.next;
            count1++;
        }
        while(index2!=null){
            index2=index2.next;
            count2++;
        }
        index1=headB;
        index2=headA;
        if(count1>count2){
            int a=count1-count2;
            while(a>0){
                index2=index2.next;
                a--;
            }
            while((index1!=null&&index2!=null)&&index1!=index2){
                index1=index1.next;
                index2=index2.next;
                
            }
            return index1==index2?(index1==null?null:index1):null;

        }else{
            int b=count2-count1;
            while(b>0){
                index1=index1.next;
                b--;
            }
            while((index1!=null&&index2!=null)&&index1!=index2){
                index1=index1.next;
                index2=index2.next;
                
            }
            return index1==index2?(index1==null?null:index1):null;
        }

    }
}
```

#### [剑指 Offer 53 - I. 在排序数组中查找数字 I](https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/)

难度简单54收藏分享切换为英文关注反馈

统计一个数字在排序数组中出现的次数。

 

**示例 1:**

```
输入: nums = [5,7,7,8,8,10], target = 8
输出: 2
```

**示例 2:**

```
输入: nums = [5,7,7,8,8,10], target = 6
输出: 0
```

 

**限制：**

```
0 <= 数组长度 <= 50000
```

 

**注意：**本题与主站 34 题相同（仅返回值不同）：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：42.9 MB, 在所有 Java 提交中击败了10.57%的用户

```java
class Solution {
    public int search(int[] nums, int target) {
        int n=nums.length;
        if(n==0)return 0;
        if(target<nums[0]||target>nums[n-1])return 0;
        int index1=find(nums,0,n-1,target);
        int index2=find(nums,0,n-1,target+1);
        if(index1==-1){
            return 0;
        }else{
            if(index2==-1){
                return n-index1;
            }else{
                return index2-index1;
            }
        }
    }
    private int find(int[] nums,int left,int right,int target){
        if(left>=right){
            return nums[left]>=target?left:-1;
        }
        int mid=left+(right-left)/2;
        if(nums[mid]<target){
            return find(nums,mid+1,right,target);
        }else{
            return find(nums,left,mid,target);
        }
    }
}
```

#### [剑指 Offer 53 - II. 0～n-1中缺失的数字](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/)

难度简单51收藏分享切换为英文关注反馈

一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。

 

**示例 1:**

```
输入: [0,1,3]
输出: 2
```

**示例 2:**

```
输入: [0,1,2,3,4,5,6,7,9]
输出: 8
```

 

**限制：**

```
1 <= 数组长度 <= 10000
```

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：40.6 MB, 在所有 Java 提交中击败了12.13%的用户

```java
class Solution {
    public int missingNumber(int[] nums) {
        int i = 0, j = nums.length - 1;
        while(i <= j) {
            int m = (i + j) / 2;
            if(nums[m] == m) i = m + 1;
            else j = m - 1;
        }
        return i;
    }
}

```

#### [剑指 Offer 54. 二叉搜索树的第k大节点](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/)

###### 未最优

难度简单50收藏分享切换为英文关注反馈

给定一棵二叉搜索树，请找出其中第k大的节点。

 

**示例 1:**

```
输入: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
输出: 4
```

**示例 2:**

```
输入: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
输出: 4
```

 

**限制：**

1 ≤ k ≤ 二叉搜索树元素个数

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：39.8 MB, 在所有 Java 提交中击败了33.15%的用户

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    int res,k;
    public int kthLargest(TreeNode root, int k) {
        this.k=k;
        inorder(root,k);
        return res;
    }
    private void inorder(TreeNode root,int k){
        if(root==null)return;
        inorder(root.right,k);
        if(k==0)return;
        if(--k==0){
            res=root.val;
            //return;
        }
        inorder(root.left,k);
       
    }
}

```

#### [剑指 Offer 55 - I. 二叉树的深度](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/)

###### 递归远快于bfs?

难度简单37收藏分享切换为英文关注反馈

输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。

例如：

给定二叉树 `[3,9,20,null,null,15,7]`，

```
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最大深度 3 。

 

**提示：**

1. `节点总数 <= 10000`

注意：本题与主站 104 题相同：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：39.7 MB, 在所有 Java 提交中击败了57.20%的用户

```java
//递归的速度远快于bfs？？？bfs只有击败22%
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null) return 0;
        int nLeft = maxDepth(root.left);
        int nRight = maxDepth(root.right);
        return nLeft > nRight ? nLeft + 1 : nRight + 1;
    }
}

class Solution {
    public int maxDepth(TreeNode root) {
        LinkedList<TreeNode> queue=new LinkedList<TreeNode>();
        if(root==null)return 0;
        queue.add(root);
        int depth=0;
        while(queue.size()>0){
            int n=queue.size();
            while(n>0){
                TreeNode temp=queue.removeFirst();
                if(temp.left!=null){
                    queue.addLast(temp.left);
                }
                if(temp.right!=null){
                    queue.addLast(temp.right);
                }
                n--;
            }
            depth++;
        }
        return depth;
    }
}
```

#### [剑指 Offer 55 - II. 平衡二叉树](https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof/)

###### 未作出

难度简单50收藏分享切换为英文关注反馈

输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。

 

**示例 1:**

给定二叉树 `[3,9,20,null,null,15,7]`

```
    3
   / \
  9  20
    /  \
   15   7
```

返回 `true` 。

**示例 2:**

给定二叉树 `[1,2,2,3,3,null,null,4,4]`

```
       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
```

返回 `false` 。

 

**限制：**

- `1 <= 树的结点个数 <= 10000`

注意：本题与主站 110 题相同：https://leetcode-cn.com/problems/balanced-binary-tree/

执行用时：1 ms, 在所有 Java 提交中击败了99.94%的用户

内存消耗：40 MB, 在所有 Java 提交中击败了25.30%的用户

```java
//Node的左子树是平衡树
//Node的右子树是平衡树
//Node的左子树和右子树的深度差值小于等于1
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    //方法作用：以node为节点的树是否平衡
    public boolean isBalanced(TreeNode node) {
        if(node == null) return true;//如果节点为空返回true
        if(!isBalanced(node.left)){//如果左子树不平衡返回false
            return false;
        }
        if(!isBalanced(node.right)){//如果右子树不平衡返回false
            return false;
        }
        //左右都为平衡
        int l = getDepth(node.left);
        int r = getDepth(node.right);
        if(Math.abs(r - l) > 1){//如果左右子树的深度相差超过一返回false
            return false;
        }
        return true;
    }
    //获取以node为根的子树深度
    public int getDepth(TreeNode node) {
        if(node == null){
            return 0;
        }
        int l = getDepth(node.left) + 1;
        int r = getDepth(node.right) + 1;
        return r>l?r:l;
    }
}

```

## 2020/8/19

#### [剑指 Offer 56 - I. 数组中数字出现的次数](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/)

难度中等193收藏分享切换为英文关注反馈

一个整型数组 `nums` 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。

 

**示例 1：**

```
输入：nums = [4,1,4,6]
输出：[1,6] 或 [6,1]
```

**示例 2：**

```
输入：nums = [1,2,10,4,1,4,3,3]
输出：[2,10] 或 [10,2]
```

 

**限制：**

- `2 <= nums.length <= 10000`

执行用时：2 ms, 在所有 Java 提交中击败了97.28%的用户

内存消耗：41.6 MB, 在所有 Java 提交中击败了27.21%的用户

```java
class Solution {
    public int[] singleNumbers(int[] nums) {
        int[] res=new int[2];
        int a=0,n=nums.length;
        for(int i=0;i<n;i++){
            a=a^nums[i];
        }
        a=a&(-a);
        
        for(int i=0;i<n;i++){
            if((nums[i]&a)==0){
                res[0]=res[0]^nums[i];
            }else{
                res[1]=res[1]^nums[i];
            }

        }
        return res;
    }
}
```

#### [剑指 Offer 56 - II. 数组中数字出现的次数 II](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/)

###### 未优化

难度中等65收藏分享切换为英文关注反馈

在一个数组 `nums` 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。

 

**示例 1：**

```
输入：nums = [3,4,3,3]
输出：4
```

**示例 2：**

```
输入：nums = [9,1,7,9,7,9,7]
输出：1
```

 

**限制：**

- `1 <= nums.length <= 10000`
- `1 <= nums[i] < 2^31`

 执行用时：5 ms, 在所有 Java 提交中击败了84.59%的用户

内存消耗：40.7 MB, 在所有 Java 提交中击败了69.83%的用户

```java
class Solution {
    public int singleNumber(int[] nums) {
        int[] counts = new int[32];
        for(int num : nums) {
            for(int j = 0; j < 32; j++) {
                counts[j] += num & 1;
                num >>>= 1;
            }
        }
        int res = 0, m = 3;
        for(int i = 0; i < 32; i++) {
            res <<= 1;
            res |= counts[31 - i] % m;
        }
        return res;
    }
}

```

#### [剑指 Offer 57 - II. 和为s的连续正数序列](https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/)

难度简单140收藏分享切换为英文关注反馈

输入一个正整数 `target` ，输出所有和为 `target` 的连续正整数序列（至少含有两个数）。

序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。

 

**示例 1：**

```
输入：target = 9
输出：[[2,3,4],[4,5]]
```

**示例 2：**

```
输入：target = 15
输出：[[1,2,3,4,5],[4,5,6],[7,8]]
```

 

**限制：**

- `1 <= target <= 10^5`

 执行用时：3 ms, 在所有 Java 提交中击败了86.78%的用户

内存消耗：37.6 MB, 在所有 Java 提交中击败了58.39%的用户

```java
class Solution {
    public int[][] findContinuousSequence(int target) {
      List<int[]> list=new ArrayList<>();
      int l=1,r=2,sum=l,rud=target/2+1;
      while(l<r&&r<=rud){
          sum+=r;
          while(sum>target){
              sum-=l;
              l++;
          }
          if(sum==target){
              int c=r-l+1;
              int[] temp=new int[c];
              for(int i=0;i<c;i++){
                  temp[i]=l+i;
              }
              list.add(temp);
          }
          r++;
      }
      int len=list.size();
        int[][] res=new int[len][];
        for(int i=0;i<len;i++){
            res[i]=list.get(i);
        }
        return res;
    }
}
```

#### [剑指 Offer 59 - I. 滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)

###### 未最优

难度简单87收藏分享切换为英文关注反馈

给定一个数组 `nums` 和滑动窗口的大小 `k`，请找出所有滑动窗口里的最大值。

**示例:**

```
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7] 
解释: 

  滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

 

**提示：**

你可以假设 *k* 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。

注意：本题与主站 239 题相同：https://leetcode-cn.com/problems/sliding-window-maximum/

行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：48.1 MB, 在所有 Java 提交中击败了60.62%的用户

```java
class Solution {
        public int[] maxSlidingWindow(int[] nums, int k) {
        int len = nums.length;
        if (len == 0){
            return new int[0];
        }
        //定义结果数组
        int[] res = new int[len - k + 1];
        //maxInd记录每次最大值的下标，max记录最大值
        int maxInd = -1, max = Integer.MIN_VALUE;

        for (int i = 0; i < len - k + 1; i++) {
            //判断最大值下标是否在滑动窗口的范围内
            if (maxInd >= i){
                //存在就只需要比较最后面的值是否大于上一个窗口最大值
                if (nums[i + k - 1] > max){
                    max = nums[i + k - 1];
                    //更新最大值下标
                    maxInd = i + k - 1;
                }
            }
            //如果不在就重新寻找当前窗口最大值
            else {
                max = nums[i];
                for (int j = i; j < i + k; j++) {
                    if (max < nums[j]) {
                        max = nums[j];
                        maxInd = j;
                    }
                }
            }
            res[i] = max;
        }
        return res;
    }

}

```

方法2只击败45%，但是易于理解，滑动窗口，双端队列，我们败在isEmpty()；

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if(nums.length == 0 || k == 0) return new int[0];
        Deque<Integer> deque = new LinkedList<>();
        int[] res = new int[nums.length - k + 1];
        for(int i = 0; i < k; i++) { // 未形成窗口
            while(!deque.isEmpty() && deque.peekLast() < nums[i])
                deque.removeLast();
            deque.addLast(nums[i]);
        }
        res[0] = deque.peekFirst();
        for(int i = k; i < nums.length; i++) { // 形成窗口后
            if(deque.peekFirst() == nums[i - k])
                deque.removeFirst();
            while(!deque.isEmpty() && deque.peekLast() < nums[i])
                deque.removeLast();
            deque.addLast(nums[i]);
            res[i - k + 1] = deque.peekFirst();
        }
        return res;
    }
}
```

## 2020/8/20

#### [剑指 Offer 59 - II. 队列的最大值](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/)

###### 未作出

难度中等133收藏分享切换为英文关注反馈

请定义一个队列并实现函数 `max_value` 得到队列里的最大值，要求函数`max_value`、`push_back` 和 `pop_front` 的**均摊**时间复杂度都是O(1)。

若队列为空，`pop_front` 和 `max_value` 需要返回 -1

**示例 1：**

```
输入: 
["MaxQueue","push_back","push_back","max_value","pop_front","max_value"]
[[],[1],[2],[],[],[]]
输出: [null,null,null,2,1,2]
```

**示例 2：**

```
输入: 
["MaxQueue","pop_front","max_value"]
[[],[],[]]
输出: [null,-1,-1]
```

 

**限制：**

- `1 <= push_back,pop_front,max_value的总操作数 <= 10000`
- `1 <= value <= 10^5`

执行用时：38 ms, 在所有 Java 提交中击败了57.95%的用户

内存消耗：49 MB, 在所有 Java 提交中击败了28.67%的用户

```java
/*
本算法基于问题的一个重要性质：当一个元素进入队列的时候，它前面所有比它小的元素就不会再对答案产生影响。

举个例子，如果我们向队列中插入数字序列 1 1 1 1 2，那么在第一个数字 2 被插入后，数字 2 前面的所有数字 1 将不会对结果产生影响。因为按照队列的取出顺序，数字 2 只能在所有的数字 1 被取出之后才能被取出，因此如果数字 1 如果在队列中，那么数字 2 必然也在队列中，使得数字 1 对结果没有影响。

按照上面的思路，我们可以设计这样的方法：从队列尾部插入元素时，我们可以提前取出队列中所有比这个元素小的元素，使得队列中只保留对结果有影响的数字。这样的方法等价于要求维持队列单调递减，即要保证每个元素的前面都没有比它小的元素。

那么如何高效实现一个始终递减的队列呢？我们只需要在插入每一个元素 value 时，从队列尾部依次取出比当前元素 value 小的元素，直到遇到一个比当前元素大的元素 value' 即可。

上面的过程保证了只要在元素 value 被插入之前队列递减，那么在 value 被插入之后队列依然递减。
而队列的初始状态（空队列）符合单调递减的定义。
由数学归纳法可知队列将会始终保持单调递减。
上面的过程需要从队列尾部取出元素，因此需要使用双端队列来实现。另外我们也需要一个辅助队列来记录所有被插入的值，以确定 pop_front 函数的返回值。

保证了队列单调递减后，求最大值时只需要直接取双端队列中的第一项即可。

时间复杂度：O(1)（插入，删除，求最大值）
删除操作于求最大值操作显然只需要 O(1) 的时间。
而插入操作虽然看起来有循环，做一个插入操作时最多可能会有 n 次出队操作。但要注意，由于每个数字只会出队一次，因此对于所有的 n 个数字的插入过程，对应的所有出队操作也不会大于 n次。因此将出队的时间均摊到每个插入操作上，时间复杂度为 O(1)。
空间复杂度：O(n)，需要用队列存储所有插入的元素。


*/
class MaxQueue {
    Deque<Integer> deque1;
    Deque<Integer> deque2;
    public MaxQueue() {
        deque1=new LinkedList<>();
        deque2=new LinkedList<>();
    }
    
    public int max_value() {
        if(deque1.isEmpty())return -1;
        return deque1.peekFirst();
    }
    
    public void push_back(int value) {
        while(!deque1.isEmpty()&&deque1.peekLast()<value){
            deque1.removeLast();
        }
        deque1.add(value);
        deque2.add(value);
    }
    
    public int pop_front() {
        if(deque2.isEmpty())return -1;
        int temp=deque2.peekFirst();
        if(temp==deque1.peekFirst()){
            deque1.removeFirst();
        }
        deque2.removeFirst();
        return temp;
    }
}

/**
 * Your MaxQueue object will be instantiated and called as such:
 * MaxQueue obj = new MaxQueue();
 * int param_1 = obj.max_value();
 * obj.push_back(value);
 * int param_3 = obj.pop_front();
 */
```

#### [剑指 Offer 60. n个骰子的点数](https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof/)

###### 未作出(dp)

难度简单94收藏分享切换为英文关注反馈

把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。

 

你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。

 

**示例 1:**

```
输入: 1
输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667]
```

**示例 2:**

```
输入: 2
输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0.05556,0.02778]
```

 

**限制：**

```
1 <= n <= 11
```

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：38 MB, 在所有 Java 提交中击败了15.85%的用户

```java
//题解说的很清楚：力扣
class Solution {
    int[] dp;
    public double[] twoSum(int n) {
        int size=6*n+1;
		dp=new int[size];
        for(int i=1;i<=6;i++){
            dp[i]=1;
        }
        for(int i=2;i<=n;i++){
            for(int j=6*i;j>=i;j--){
                dp[j]=0;
                for(int k=1;k<=6;k++){
                    if(j-k<i-1){
                        break;
                    }
                    dp[j]+=dp[j-k];
                }
            }
        }
        double[] res=new double[5*n+1];
        double all=Math.pow(6,n);
        for(int i=n;i<size;i++){
            res[i-n]=(double)(dp[i]*1.0/all);
        }
        return res;
	}

}
```

#### [剑指 Offer 61. 扑克牌中的顺子](https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof/)

###### 未作出

难度简单56收藏分享切换为英文关注反馈

从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。

 

**示例 1:**

```
输入: [1,2,3,4,5]
输出: True
```

 

**示例 2:**

```
输入: [0,0,1,2,5]
输出: True
```

 

**限制：**

数组长度为 5 

数组的数取值为 [0, 13] .

执行用时：1 ms, 在所有 Java 提交中击败了90.85%的用户

内存消耗：37 MB, 在所有 Java 提交中击败了94.25%的用户

```
class Solution {
    public boolean isStraight(int[] nums) {
        int count0=0;
        int n=nums.length;
        Arrays.sort(nums);
        for(int num:nums){
            if(num==0){
                count0++;
            }
        }
        for(int i=count0;i<n-1;i++){
            if(nums[i+1]==nums[i]){
                return false;
            }else{
                count0-=(nums[i+1]-nums[i]-1);
            }
        }
        return count0>=0;
    }
}
```

## 2020/8/21

#### [剑指 Offer 62. 圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)

###### 未作出

难度简单201收藏分享切换为英文关注反馈

0,1,,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字。求出这个圆圈里剩下的最后一个数字。

例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。

 

**示例 1：**

```
输入: n = 5, m = 3
输出: 3
```

**示例 2：**

```
输入: n = 10, m = 17
输出: 2
```

 

**限制：**

- `1 <= n <= 10^5`
- `1 <= m <= 10^6`

执行用时：7 ms, 在所有 Java 提交中击败了99.98%的用户

内存消耗：36.5 MB, 在所有 Java 提交中击败了63.99%的用户

<img src="%E5%89%91%E6%8C%87%E9%A2%98%E8%A7%A3.assets/image-20200821154903790.png" alt="image-20200821154903790" style="zoom: 80%;" />

```java
/*n个数字的圆圈，不断删除第m个数字，我们把最后剩下的数字记为f(n,m)
n个数字中第一个被删除的数字是(m-1)%n (取余的原因是m可能比n大)， 我们记作k，k=(m-1)%n
那么剩下的n-1个数字就变成了：0,1,……k-1,k+1,……,n-1，我们把下一轮第一个数字排在最前面，并且将这个长度为n-1的数组映射到0~n-2。*/
class Solution {
    public int lastRemaining(int n, int m) {
        int ans = 0;
        // 最后一轮剩下2个人，所以从2开始反推
        for (int i = 2; i <= n; i++) {
            ans = (ans + m) % i;
        }
        return ans;
    }
}
```

#### [剑指 Offer 63. 股票的最大利润](https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/)

难度中等49

假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？

 

**示例 1:**

```
输入: [7,1,5,3,6,4]
输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。
```

**示例 2:**

```
输入: [7,6,4,3,1]
输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。
```

 

**限制：**

```
0 <= 数组长度 <= 10^5
```

 

**注意：**本题与主站 121 题相同：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/

执行用时：1 ms, 在所有 Java 提交中击败了98.95%的用户

内存消耗：39.6 MB, 在所有 Java 提交中击败了66.36%的用户

```java
class Solution {
    public int maxProfit(int[] prices) {
       if(prices == null || prices.length <= 1) {
            return 0;
        }
        int res = 0, min = prices[0];
        for(int i = 1; i < prices.length; i++) {
            if(prices[i] <= min) {
                min = prices[i];
            }else {
                res = Math.max(res, prices[i] - min);
            }
        }
        return res;
    }
}
```

#### [剑指 Offer 64. 求1+2+…+n](https://leetcode-cn.com/problems/qiu-12n-lcof/)

###### 未作出

难度中等187

求 `1+2+...+n` ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。

 

**示例 1：**

```
输入: n = 3
输出: 6
```

**示例 2：**

```
输入: n = 9
输出: 45
```

 

**限制：**

- `1 <= n <= 10000`

执行用时：1 ms, 在所有 Java 提交中击败了62.91%的用户

内存消耗：36.8 MB, 在所有 Java 提交中击败了55.59%的用户

```Java
class Solution {
    public int sumNums(int n) {
        int sum=n;
        boolean flag=n>0&&(sum+=sumNums(n-1))>0;
        return sum;
    }
}
```

#### [剑指 Offer 65. 不用加减乘除做加法](https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/)

###### 未作出（不理解负数的情况下为什么这种方法对）

难度简单61

写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。

 

**示例:**

```
输入: a = 1, b = 1
输出: 2
```

 

**提示：**

- `a`, `b` 均可能是负数或 0
- 结果不会溢出 32 位整数

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：36.2 MB, 在所有 Java 提交中击败了84.17%的用户

```java
class Solution {
    public int add(int a, int b) {
        return b == 0 ? a : add(a ^ b, (a & b) << 1);
    }
}
```

## 2020/8/22

#### [剑指 Offer 66. 构建乘积数组](https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/)

难度简单38

给定一个数组 `A[0,1,…,n-1]`，请构建一个数组 `B[0,1,…,n-1]`，其中 `B` 中的元素 `B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]`。不能使用除法。

 

**示例:**

```
输入: [1,2,3,4,5]
输出: [120,60,40,30,24]
```

 

**提示：**

- 所有元素乘积之和不会溢出 32 位整数
- `a.length <= 100000`

执行用时：2 ms, 在所有 Java 提交中击败了83.76%的用户

内存消耗：52.6 MB, 在所有 Java 提交中击败了20.75%的用户

```java
class Solution {
    public int[] constructArr(int[] a) {
        int temp=1;
        int n=a.length;
        int[] left=new int[n];
        int[] right=new int[n];
        for(int i=1;i<=n;i++){
           
            left[i-1]=temp;
             temp*=a[i-1];
        }
        //left[0]=1;
        temp=1;
        for(int i=n-1;i>=0;i--){
            
            right[i]=left[i]*temp;
            temp*=a[i];
        }
        //right[n-1]=left[n-1];
        return right;
    }
}
```

## 2020/8/27

#### [剑指 Offer 67. 把字符串转换成整数](https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/)

###### 未作出

难度中等30

写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。

 

首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。

当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。

该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。

注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。

在任何情况下，若函数不能进行有效的转换时，请返回 0。

**说明：**

假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回  INT_MAX (231 − 1) 或 INT_MIN (−231) 。

**示例 1:**

```
输入: "42"
输出: 42
```

**示例 2:**

```
输入: "   -42"
输出: -42
解释: 第一个非空白字符为 '-', 它是一个负号。
     我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。
```

**示例 3:**

```
输入: "4193 with words"
输出: 4193
解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。
```

**示例 4:**

```
输入: "words and 987"
输出: 0
解释: 第一个非空字符是 'w', 但它不是数字或正、负号。
     因此无法执行有效的转换。
```

**示例 5:**

```
输入: "-91283472332"
输出: -2147483648
解释: 数字 "-91283472332" 超过 32 位有符号整数范围。 
     因此返回 INT_MIN (−231) 。
```

 

注意：本题与主站 8 题相同：https://leetcode-cn.com/problems/string-to-integer-atoi/

执行用时：2 ms, 在所有 Java 提交中击败了99.91%的用户

内存消耗：39.9 MB, 在所有 Java 提交中击败了10.25%的用户

```java
class Solution {
    public int strToInt(String str) {
        str = str.trim();
        char[] chars = str.toCharArray();

        int res = 0;    // 转换结果
        int sign = 1;   // 表示 符号位，直接与结果相乘 即可
        int index = 1;  // 遍历 chars数组 的 下标
        int border = Integer.MAX_VALUE / 10;    // 用于判断 当前数字 是否 到达最大值 的1/10，以便后续处理

        if (chars.length <= 0) {
            return 0;
        }

        if (chars[0] == '-') {
            sign = -1;
        } else if (chars[0] != '+') {
            index = 0;
        }

        for (; index < chars.length; index++) {
            char curChar = chars[index];
            if (curChar < '0' || curChar > '9') {
                break;
            }
            if (res > border || (res == border && curChar>'7')) {
                return sign == -1 ? Integer.MIN_VALUE : Integer.MAX_VALUE;
            }
            res = res * 10 + curChar - '0';
        }

        return sign * res;
    }
}

```

#### [剑指 Offer 68 - I. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

###### 未作出

难度简单54

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]

![img](%E5%89%91%E6%8C%87%E9%A2%98%E8%A7%A3.assets/binarysearchtree_improved.png)

 

**示例 1:**

```
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。
```

**示例 2:**

```
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。
```

 

**说明:**

- 所有节点的值都是唯一的。
- p、q 为不同节点且均存在于给定的二叉搜索树中。

注意：本题与主站 235 题相同：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/

执行用时：6 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：41 MB, 在所有 Java 提交中击败了75.11%的用户

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
         if (root == null)
            return null;
        
        if (root.val > p.val && root.val > q.val)
            return lowestCommonAncestor(root.left, p, q);
        if (root.val < p.val && root.val < q.val)
            return lowestCommonAncestor(root.right, p, q);

        return root;
    }
}
```

#### [剑指 Offer 68 - II. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/)

###### 未作出

难度简单121

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]

![img](%E5%89%91%E6%8C%87%E9%A2%98%E8%A7%A3.assets/binarytree.png)

 

**示例 1:**

```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
```

**示例 2:**

```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。
```

 

**说明:**

- 所有节点的值都是唯一的。
- p、q 为不同节点且均存在于给定的二叉树中。

注意：本题与主站 236 题相同：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/

执行用时：7 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：41.9 MB, 在所有 Java 提交中击败了44.11%的用户

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null) return null; // 如果树为空，直接返回null
        if(root == p || root == q) return root; // 如果 p和q中有等于 root的，那么它们的最近公共祖先即为root（一个节点也可以是它自己的祖先）
        TreeNode left = lowestCommonAncestor(root.left, p, q); // 递归遍历左子树，只要在左子树中找到了p或q，则先找到谁就返回谁
        TreeNode right = lowestCommonAncestor(root.right, p, q); // 递归遍历右子树，只要在右子树中找到了p或q，则先找到谁就返回谁
        if(left == null) return right; // 如果在左子树中 p和 q都找不到，则 p和 q一定都在右子树中，右子树中先遍历到的那个就是最近公共祖先（一个节点也可以是它自己的祖先）
        else if(right == null) return left; // 否则，如果 left不为空，在左子树中有找到节点（p或q），这时候要再判断一下右子树中的情况，如果在右子树中，p和q都找不到，则 p和q一定都在左子树中，左子树中先遍历到的那个就是最近公共祖先（一个节点也可以是它自己的祖先）
        else return root; //否则，当 left和 right均不为空时，说明 p、q节点分别在 root异侧, 最近公共祖先即为 root
    }
}
```

