# 面试题题解

## 2020/6/18

#### [面试题03. 数组中重复的数字](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)

难度简单87收藏分享切换为英文关注反馈

找出数组中重复的数字。
在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

**示例 1：**

```
输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3  
```

**限制：**

```
2 <= n <= 100000
```

执行用时 :0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗 :48 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    public int findRepeatNumber(int[] nums) {
        if(nums==null||nums.length<2)return -1;
        int n=nums.length;
        int i=0;
        while(i<n){
            //判断i位置的值是否为i；
            if(nums[i]==i){
                i++;
                continue;
            }else{
                //判断nums[i]是否等于nums[i]本该在位置的值
                if(nums[i]==nums[nums[i]]){
                    return nums[i];
                }else{
                    swap(nums,i,nums[i]);
                }
            }
        }
        return -1;
    }
    private void swap(int[] nums,int i,int j){
        int a=nums[j];
        nums[j]=nums[i];
        nums[i]=a;
    }
}
```

#### [面试题04. 二维数组中的查找](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/)

难度简单87收藏分享切换为英文关注反馈

在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

**示例:**

现有矩阵 matrix 如下：

```
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
```

给定 target = `5`，返回 `true`。

给定 target = `20`，返回 `false`。

**限制：**

```
0 <= n <= 1000
0 <= m <= 1000
```

执行用时 :0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗 :45.8 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    public boolean findNumberIn2DArray(int[][] matrix, int target) {
        if(matrix==null||matrix.length==0||matrix[0].length==0)return false;
        int m=matrix.length,n=matrix[0].length;
        int i=0,j=n-1;
        while(i>=0&&i<m&&j<=n-1&&j>=0){
            if(matrix[i][j]==target){
                return true;
            }else if(matrix[i][j]>target){
                j--;
            }else{
                i++;
            }
        }
        return false;
    }
}
```

#### [面试题05. 替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)

难度简单21收藏分享切换为英文关注反馈

请实现一个函数，把字符串 `s` 中的每个空格替换成"%20"。

**示例 1：**

```
输入：s = "We are happy."
输出："We%20are%20happy."
```

**限制：**

```
0 <= s 的长度 <= 10000
```

执行用时 :0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗 :37.5 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    public String replaceSpace(String s) {
      if(s==null)return "";
      int n=s.length();
      StringBuilder sb=new StringBuilder();
      for(int i=0;i<n;i++){
          char c=s.charAt(i);
          if(c==' '){
              sb.append("%20");
          }else{
              sb.append(c);
          }
      }
      return sb.toString();  
    }
}
```

#### [面试题06. 从尾到头打印链表](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)

难度简单32收藏分享切换为英文关注反馈

输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。

**示例 1：**

```
输入：head = [1,3,2]
输出：[2,3,1] 
```

**限制：**

```
0 <= 链表长度 <= 10000
```

执行用时 :0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗 :40.6 MB, 在所有 Java 提交中击败了100.00%的用户

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
//用stack来后进先出的话，会比下面的多出往stack里push的操作，不如下面的方法。
class Solution {
    public static int[] reversePrint(ListNode head) {
        ListNode node = head;
        int count = 0;
        while (node != null) {
            ++count;
            node = node.next;
        }
        int[] nums = new int[count];
        node = head;
        for (int i = count - 1; i >= 0; --i) {
            nums[i] = node.val;
            node = node.next;
        }
        return nums;
    }
}
```

#### [面试题07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

###### 未作出

难度中等114收藏分享切换为英文关注反馈

输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。

例如，给出

```
前序遍历 preorder = [3,9,20,15,7]
中序遍历 inorder = [9,3,15,20,7]
```

返回如下的二叉树：

```
    3
   / \
  9  20
    /  \
   15   7
```

**限制：**

```
0 <= 节点个数 <= 5000
```

执行用时 :3 ms, 在所有 Java 提交中击败了81.39%的用户

内存消耗 :40.2 MB, 在所有 Java 提交中击败了100.00%的用户

```java
/**二叉树的前序遍历顺序是：根节点、左子树、右子树，每个子树的遍历顺序同样满足前序遍历顺序。

二叉树的中序遍历顺序是：左子树、根节点、右子树，每个子树的遍历顺序同样满足中序遍历顺序。

前序遍历的第一个节点是根节点，只要找到根节点在中序遍历中的位置，在根节点之前被访问的节点都位于左子树，在根节点之后被访问的节点都位于右子树，由此可知左子树和右子树分别有多少个节点。

由于树中的节点数量与遍历方式无关，通过中序遍历得知左子树和右子树的节点数量之后，可以根据节点数量得到前序遍历中的左子树和右子树的分界，因此可以进一步得到左子树和右子树各自的前序遍历和中序遍历，可以通过递归的方式，重建左子树和右子树，然后重建整个二叉树。

使用一个 Map 存储中序遍历的每个元素及其对应的下标，目的是为了快速获得一个元素在中序遍历中的位置。调用递归方法，对于前序遍历和中序遍历，下标范围都是从 0 到 n-1，其中 n 是二叉树节点个数。

递归方法的基准情形有两个：判断前序遍历的下标范围的开始和结束，若开始大于结束，则当前的二叉树中没有节点，返回空值 null。若开始等于结束，则当前的二叉树中恰好有一个节点，根据节点值创建该节点作为根节点并返回。
若开始小于结束，则当前的二叉树中有多个节点。在中序遍历中得到根节点的位置，从而得到左子树和右子树各自的下标范围和节点数量，知道节点数量后，在前序遍历中即可得到左子树和右子树各自的下标范围，然后递归重建左子树和右子树，并将左右子树的根节点分别作为当前根节点的左右子节点。
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    Map<Integer,Integer> map=new HashMap<>();
    public TreeNode buildTree(int[] preorder, int[] inorder) {
      int n=preorder.length;
      for(int i=0;i<n;i++){
          map.put(inorder[i],i);
      }
        
        return help(preorder,0,n-1,0);
    }
    private TreeNode help(int[] preorder,int leftIndex,int rightIndex,int inorderLeft){
        if(leftIndex>rightIndex){
            return null;
        }
        TreeNode root=new TreeNode(preorder[leftIndex]);
        int leftSize=map.get(preorder[leftIndex])-inorderLeft;
        TreeNode nodeLeft=help(preorder,leftIndex+1,leftIndex+leftSize,inorderLeft);
        TreeNode nodeRight=help(preorder,leftIndex+leftSize+1,rightIndex,inorderLeft+leftSize+1);
        root.left=nodeLeft;
        root.right=nodeRight;
        return root;
    }
}
```

## 2020/6/19

#### [面试题09. 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)

难度简单46收藏分享切换为英文关注反馈

用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 `appendTail` 和 `deleteHead` ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，`deleteHead` 操作返回 -1 )

**示例 1：**

```
输入：
["CQueue","appendTail","deleteHead","deleteHead"]
[[],[3],[],[]]
输出：[null,null,3,-1]
```

**示例 2：**

```
输入：
["CQueue","deleteHead","appendTail","appendTail","deleteHead","deleteHead"]
[[],[],[5],[2],[],[]]
输出：[null,-1,null,null,5,2]
```

**提示：**

- `1 <= values <= 10000`
- `最多会对 appendTail、deleteHead 进行 10000 次调用`

执行用时 :55 ms, 在所有 Java 提交中击败了86.59%的用户

内存消耗 :47.8 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class CQueue {
    Stack<Integer> stack1;
    Stack<Integer> stack2;
    public CQueue() {
        stack1=new Stack<Integer>();
        stack2=new Stack<Integer>();
    }
    
    public void appendTail(int value) {
        stack1.push(value);
    }
    
    public int deleteHead() {
        if(!stack2.isEmpty()){
            return stack2.pop();
        }else{
            if(!stack1.isEmpty()){
                while(!stack1.isEmpty()){
                    int temp=stack1.pop();
                    stack2.push(temp);
                }
                return stack2.pop();
            }else{
                return -1;
            }
        }
    }
}

/**
 * Your CQueue object will be instantiated and called as such:
 * CQueue obj = new CQueue();
 * obj.appendTail(value);
 * int param_2 = obj.deleteHead();
 */
```

#### [剑指 Offer 10- I. 斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)

难度简单28收藏分享切换为英文关注反馈

写一个函数，输入 `n` ，求斐波那契（Fibonacci）数列的第 `n` 项。斐波那契数列的定义如下：

```
F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
```

斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

**示例 1：**

```
输入：n = 2
输出：1
```

**示例 2：**

```
输入：n = 5
输出：5
```

**提示：**

- `0 <= n <= 100`

执行用时 :0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗 :36.6 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    public int fib(int n) {
        if(n<2) return n;
        int pre2=0,pre1=1;
        int temp=0;
        for(int i=2;i<=n;i++){
            temp=pre1;
            pre1=(pre1+pre2)%1000000007;
            pre2=temp;
        }
        return pre1;
    }
}
```

#### [面试题 01.01. 判定字符是否唯一](https://leetcode-cn.com/problems/is-unique-lcci/)

###### 未作出进阶

难度简单37收藏分享切换为英文关注反馈

实现一个算法，确定一个字符串 `s` 的所有字符是否全都不同。

**示例 1：**

```
输入: s = "leetcode"
输出: false 
```

**示例 2：**

```
输入: s = "abc"
输出: true
```

**限制：**

- `0 <= len(s) <= 100`
- 如果**你不使用额外的数据结构**，会很加分。

执行用时 :0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗 :37.4 MB, 在所有 Java 提交中击败了100.00%的用户

2个解法都是双百

```java
//一
   //从左右分别搜索同一个字符，看第一次碰到的索引是否相等，不等就false
class Solution {
    public boolean isUnique(String astr) {
        
        int n=astr.length();
        for(int i=0;i<n;i++){
            if(astr.lastIndexOf(astr.charAt(i))!=astr.indexOf(astr.charAt(i))){
                return false;
            }
        }
        return true;
        
    }
}

//二
	//根据位运算，对于一个字符c，检查对应下标的bit值即可判断是否重复。那么难点在于如何检查？这里我们可以通过位运算来完成。首先计算出字符char离'a'这个字符的距离，即我们要位移的距离，用temp表示，那么使用左移运算符1 << temp则可以得到对应下标为1，其余下标为0的数，如字符char = 'c'，则得到的数为000...00100，将这个数跟mark做与运算，由于这个数只有一个位为1，其他位为0，那么与运算的结果中，其他位肯定是0，而对应的下标位是否0则取决于之前这个字符有没有出现过，若出现过则被标记为1，那么与运算的结果就不为0；若之前没有出现过，则对应位的与运算的结果也是0，那么整个结果也为0。对于没有出现过的字符，我们用或运算mark | (1 << temp)将对应下标位的值置为1。
class Solution {
    public boolean isUnique(String astr) {
        int mark=0;
        int n=astr.length();
        int c;
        int temp;
        for(int i=0;i<n;i++){
            c=astr.charAt(i)-'a';
            temp=(1<<c);
            if((temp&mark)==0){
                mark|=temp;
            }else{
                return false;
            }
        }
        return true;
        
    }
}
```

#### [面试题 01.02. 判定是否互为字符重排](https://leetcode-cn.com/problems/check-permutation-lcci/)

难度简单12收藏分享切换为英文关注反馈

给定两个字符串 `s1` 和 `s2`，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。

**示例 1：**

```
输入: s1 = "abc", s2 = "bca"
输出: true 
```

**示例 2：**

```
输入: s1 = "abc", s2 = "bad"
输出: false
```

**说明：**

- `0 <= len(s1) <= 100`
- `0 <= len(s2) <= 100`

执行用时 :0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗 :37.4 MB, 在所有 Java 提交中击败了100.00%的用户

```java
//ASCII 十进制从0到127，共128个字符
class Solution {
    public boolean CheckPermutation(String s1, String s2) {
        int n1=s1.length(),n2=s2.length();
        if(n1!=n2) return false;
        int[] index=new int[128];
        for(int i=0;i<n1;i++){
            index[s1.charAt(i)]++;
            index[s2.charAt(i)]--;
        }
        for(int i=0;i<128;i++){
            if(index[i]!=0){
                return false;
            }
        }
        return true;
    }
}
```

#### [面试题 01.03. URL化](https://leetcode-cn.com/problems/string-to-url-lcci/)

难度简单9收藏分享切换为英文关注反馈

URL化。编写一种方法，将字符串中的空格全部替换为`%20`。假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。（注：**用`Java`实现的话，请使用字符数组实现，以便直接在数组上操作**。）

**示例1:**

```
 输入："Mr John Smith    ", 13
 输出："Mr%20John%20Smith"
```

**示例2:**

```
 输入："               ", 5
 输出："%20%20%20%20%20"
```

**提示：**

1. 字符串长度在[0, 500000]范围内。

执行用时 :12 ms, 在所有 Java 提交中击败了82.13%的用户

内存消耗 :47.5 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    public String replaceSpaces(String S, int length) {
         char[] s = S.toCharArray();
        int M = 0;   //有效空格数
        int j = 0;   //供替换时使用
        int N = length;   //有效操作长度

        //得到原数组有效空格数
        for (int i = 0; i < N; i++) {
            if (s[i] == ' '){
                M ++;
            }
        }
        //得到结果数组的有效长度
        M = M * 2 + N;
        char[] arr = new char[M];
        //进行替换
        for (int i = 0; i < N; i++) {
            if (s[i] == ' '){
                arr[j++] = '%';
                arr[j++] = '2';
                arr[j++] = '0';
            }else{
                arr[j++] = s[i];
            }
        }
        return new String(arr);
    }
}
```

#### [面试题 01.04. 回文排列](https://leetcode-cn.com/problems/palindrome-permutation-lcci/)

难度简单25收藏分享切换为英文关注反馈

给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。

回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。

回文串不一定是字典当中的单词。

**示例1：**

```
输入："tactcoa"
输出：true（排列有"tacocat"、"atcocta"，等等）
```

执行用时 :0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗 :37.2 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    public boolean canPermutePalindrome(String s) {
        int n=s.length();
        if(n<2) return true;
        char[] c=s.toCharArray();
        int[] num=new int[128];
        for(int i=0;i<n;i++){
            num[c[i]]++;
        }
        int count=0;
        for(int i=0;i<128;i++){
            if(num[i]%2==1){
                count++;
            }
        }
        return count<2;
    }
}
```

#### [面试题 01.05. 一次编辑](https://leetcode-cn.com/problems/one-away-lcci/)

难度中等25收藏分享切换为英文关注反馈

字符串有三种编辑操作:插入一个字符、删除一个字符或者替换一个字符。 给定两个字符串，编写一个函数判定它们是否只需要一次(或者零次)编辑。

**示例 1:**

```
输入: 
first = "pale"
second = "ple"
输出: True
```

**示例 2:**

```
输入: 
first = "pales"
second = "pal"
输出: False
```

执行用时 :2 ms, 在所有 Java 提交中击败了99.42%的用户

内存消耗 :39.8 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    public boolean oneEditAway(String first, String second) {
      int n1=first.length(),n2=second.length();
      if(n1>n2+1||n2>n1+1) return false;
      if(n1==n2){
          int differ=0;
          for(int i=0;i<n1;i++){
              if(differ<2){
                  if(first.charAt(i)!=second.charAt(i)){
                     differ++;
                    }
                }
                if(differ>1){
                    return false;
                }
          }
      }else if(n1>n2){
          int differ=0;
          for(int i=0;i<n2;i++){
              if(differ<2){
                  if(first.charAt(i+differ)!=second.charAt(i)){
                      differ++;
                      i--;  
                  }
              }
            if(differ>1){
                    return false;
                }
          }
      }else{
          int differ=0;
          for(int i=0;i<n1;i++){
              if(differ<2){
                  if(first.charAt(i)!=second.charAt(i+differ)){
                      differ++;
                      i--;  
                  }
              }
              if(differ>1){
                    return false;
                }
          }
      }
      return true;  
    }
}
```

#### [面试题 01.06. 字符串压缩](https://leetcode-cn.com/problems/compress-string-lcci/)

难度简单43收藏分享切换为英文关注反馈

字符串压缩。利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串`aabcccccaaa`会变为`a2b1c5a3`。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。

**示例1:**

```
 输入："aabcccccaaa"
 输出："a2b1c5a3"
```

**示例2:**

```
 输入："abbccd"
 输出："abbccd"
 解释："abbccd"压缩后为"a1b2c2d1"，比原字符串长度更长。
```

**提示：**

1. 字符串长度在[0, 50000]范围内。

执行用时 :5 ms, 在所有 Java 提交中击败了80.36%的用户

内存消耗 :39.8 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    public String compressString(String S) {
        int n=S.length();
        if(n<2)return S;
        StringBuilder sb=new StringBuilder();
        //sb.append(S.charAt(0));
        int sum=1;
        for(int i=1;i<n;i++){
            if(S.charAt(i)==S.charAt(i-1)){
                sum++;
            }else{
                sb.append(S.charAt(i-1));
                sb.append(sum);
                sum=1;
            }
        }
        sb.append(S.charAt(n-1));
        sb.append(sum);
        String s=sb.toString();
        if(s.length()<n){
            return s;
        }else{
            return S;
        }
    }
}
```

## 2020/6/20

#### [面试题 01.07. 旋转矩阵](https://leetcode-cn.com/problems/rotate-matrix-lcci/)

###### 未作出进阶

难度中等93收藏分享切换为英文关注反馈

给你一幅由 `N × N` 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。

**不占用额外内存空间**能否做到？

**示例 1:**

```
给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```

**示例 2:**

```
给定 matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

原地旋转输入矩阵，使其变为:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
```

执行用时 :0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗 :39.5 MB, 在所有 Java 提交中击败了100.00%的用户

```java
//不占用额外空间，想到了正确的转换方式，但是没想到拆分开来，以达到不占用额外空间
//由于矩阵中的行列从 00 开始计数，因此对于矩阵中的元素 matrix[row][col]，在旋转后，它的新位置为 matrix[col][n−row−1]。
//matrix[row][col]->水平轴翻转->matrix[n−row−1][col]->主对角线翻转->matrix[col][n−row−1]
class Solution {
    public void rotate(int[][] matrix) {
        if(matrix==null||matrix.length==0||matrix[0].length==0) return;
        int m=matrix.length,n=matrix[0].length;
        if(m!=n)return;
        int temp=0;
        for(int i=0;i<n/2;i++){
            for(int j=0;j<n;j++){
                temp=matrix[i][j];
                matrix[i][j]=matrix[n-1-i][j];
                matrix[n-1-i][j]=temp;
            }
        }
        for(int i=0;i<n;i++){
            for(int j=i+1;j<n;j++){
                temp=matrix[i][j];
                matrix[i][j]=matrix[j][i];
                matrix[j][i]=temp;
            }
        }
        return;
    }
}
```

#### [面试题 01.08. 零矩阵](https://leetcode-cn.com/problems/zero-matrix-lcci/)

难度中等7收藏分享切换为英文关注反馈

编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。

**示例 1：**

```
输入：
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
输出：
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]
```

**示例 2：**

```
输入：
[
  [0,1,2,0],
  [3,4,5,2],
  [1,3,1,5]
]
输出：
[
  [0,0,0,0],
  [0,4,5,0],
  [0,3,1,0]
]
```

执行用时 :1 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗 :41.4 MB, 在所有 Java 提交中击败了100.00%的用户

```java
//我初始用的HashSet来保存行列值，但是这个存储Set内部的去重会花费比用数组保存更多的时间，以后记得优化的一个方向，像是这题这样，改用boolean数组来提升；
class Solution {
    public void setZeroes(int[][] matrix) {
         boolean[] row = new boolean[matrix.length];
        boolean[] column = new boolean[matrix[0].length];
        // 找出要清零的行列
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                if (matrix[i][j] == 0) {
                    row[i] = true;
                    column[j] = true;
                }
            }
        }
        
        // 开始对行清零
        for (int i = 0; i < matrix.length; i++) {
            if (row[i]) {
                for (int j = 0; j < matrix[0].length; j++) {
                    matrix[i][j] = 0;
                }
            }
        }

        // 开始对列清零
        for (int i = 0; i < matrix[0].length; i++) {
            if (column[i]) {
                for (int j = 0; j < matrix.length; j++) {
                    matrix[j][i] = 0;
                }
            }
        }
    }
}
```

#### [面试题 01.09. 字符串轮转](https://leetcode-cn.com/problems/string-rotation-lcci/)

###### 未作出进阶，待研究string的contains方法可以双百，为什么能那么快？

难度简单24收藏分享切换为英文关注反馈

字符串轮转。给定两个字符串`s1`和`s2`，请编写代码检查`s2`是否为`s1`旋转而成（比如，`waterbottle`是`erbottlewat`旋转后的字符串）。

**示例1:**

```
 输入：s1 = "waterbottle", s2 = "erbottlewat"
 输出：True
```

**示例2:**

```
 输入：s1 = "aa", s2 = "aba"
 输出：False
```

**提示：**

1. 字符串长度在[0, 100000]范围内。

**说明:**

1. **你能只调用一次检查子串的方法**吗？

执行用时 :4 ms, 在所有 Java 提交中击败了22.26%的用户

内存消耗 :39.9 MB, 在所有 Java 提交中击败了100.00%的用户

```
class Solution {
    public boolean isFlipedString(String s1, String s2) {
        if(s1.length() != s2.length()) return false;
        int n=s1.length();
        s1 += s1;
        int i = 0,j=0,n2=2*n;
        while(i != n2 && j != n){
            if(s1.charAt(i) == s2.charAt(j)){
                i++;j++;
            }else{
                j = 0;
                i++;
            }
        }
        return j == n;
    }
}
```

#### [面试题 02.01. 移除重复节点](https://leetcode-cn.com/problems/remove-duplicate-node-lcci/)

###### 未作出进阶，用ArrayList比HashSet慢太多太多了，待查明速度差距原因，2个集合差别

难度简单26收藏分享切换为英文关注反馈

编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。

**示例1:**

```
 输入：[1, 2, 3, 3, 2, 1]
 输出：[1, 2, 3]
```

**示例2:**

```
 输入：[1, 1, 1, 1, 2]
 输出：[1, 2]
```

**提示：**

1. 链表长度在[0, 20000]范围内。
2. 链表元素在[0, 20000]范围内。

**进阶：**

如果**不得使用临时缓冲区**，该怎么解决？

执行用时 :6 ms, 在所有 Java 提交中击败了79.66%的用户

内存消耗 :41 MB, 在所有 Java 提交中击败了100.00%的用户

```java
//不使用缓冲区，即原址操作
//用ArrayList比HashSet慢太多太多了，
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode removeDuplicateNodes(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        Set<Integer> set = new HashSet<>();
        set.add(head.val);
        ListNode pre = head;
        ListNode node = pre.next;
        while (node != null) {
            if (set.contains(node.val)) {
                node = node.next;
                pre.next = node;
            } else {
                set.add(node.val);
                pre.next = new ListNode(node.val);
                node = node.next;
                pre = pre.next;
            }
        }
        return head;
    }
}
```

#### [面试题 02.02. 返回倒数第 k 个节点](https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/)

###### 方法上差了很多

难度简单30收藏分享切换为英文关注反馈

实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。

**注意：**本题相对原题稍作改动

**示例：**

```
输入： 1->2->3->4->5 和 k = 2
输出： 4
```

**说明：**

给定的 *k* 保证是有效的。

执行用时 :0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗 :37.3 MB, 在所有 Java 提交中击败了100.00%的用户

```java
//双指针思想比用stack来push,pop会快很多
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public int kthToLast(ListNode head, int k) {
        ListNode cur=head;
        for(int i=0;i<k;i++){
            cur=cur.next;
        }
        while(cur!=null){
            cur=cur.next;
            head=head.next;
        }
        return head.val;
    }
}
```

#### [面试题 02.03. 删除中间节点](https://leetcode-cn.com/problems/delete-middle-node-lcci/)

难度简单29收藏分享切换为英文关注反馈

实现一种算法，删除单向链表中间的某个节点（即不是第一个或最后一个节点），假定你只能访问该节点。

**示例：**

```
输入：单向链表a->b->c->d->e->f中的节点c
结果：不返回任何数据，但该链表变为a->b->d->e->f
```

执行用时 :0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗 :39.2 MB, 在所有 Java 提交中击败了100.00%的用户

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public void deleteNode(ListNode node) {
        while(node.next.next!=null){
            node.val=node.next.val;
            node=node.next;
        }
        node.val=node.next.val;
        node.next=null;
    }
}
```

## 2020/6/21

#### [面试题 02.04. 分割链表](https://leetcode-cn.com/problems/partition-list-lcci/)

难度中等18收藏分享切换为英文关注反馈

编写程序以 x 为基准分割链表，使得所有小于 x 的节点排在大于或等于 x 的节点之前。如果链表中包含 x，x 只需出现在小于 x 的元素之后(如下所示)。分割元素 x 只需处于“右半部分”即可，其不需要被置于左右两部分之间。

**示例:**

```
输入: head = 3->5->8->5->10->2->1, x = 5
输出: 3->1->2->10->5->5->8
```

执行用时 :0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗 :39.4 MB, 在所有 Java 提交中击败了100.00%的用户

```java
//一普通思维
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode partition(ListNode head, int x) {
     ListNode root=new ListNode(-1);
     ListNode node=root;
     ListNode temp=head;
     while(temp!=null){
         if(temp.val<x){
             node.next=new ListNode(temp.val);
             node=node.next;
         }
         temp=temp.next;
     }
     temp=head;
     while(temp!=null){
         if(temp.val>=x){
             node.next=new ListNode(temp.val);
             node=node.next;
         }
         temp=temp.next;
     }
     return root.next;   
    }
}
```

```java
//原址排序，拿出一个指针指向小于x的节点，来遍历一遍，交换值就可以了，最佳的
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode partition(ListNode head, int x) {
        ListNode cur = head, prev = head;
        while (cur != null) {
            if (cur.val < x) {
                int tmp = prev.val;
                prev.val = cur.val;
                cur.val = tmp;
                prev = prev.next;
            }
            cur = cur.next;
        }
        return head;
    }
}
```

#### [面试题 02.05. 链表求和](https://leetcode-cn.com/problems/sum-lists-lcci/)

难度中等22收藏分享切换为英文关注反馈

给定两个用链表表示的整数，每个节点包含一个数位。

这些数位是反向存放的，也就是个位排在链表首部。

编写函数对这两个整数求和，并用链表形式返回结果。

**示例：**

```
输入：(7 -> 1 -> 6) + (5 -> 9 -> 2)，即617 + 295
输出：2 -> 1 -> 9，即912
```

**进阶：**假设这些数位是正向存放的，请再做一遍。

**示例：**

```
输入：(6 -> 1 -> 7) + (2 -> 9 -> 5)，即617 + 295
输出：9 -> 1 -> 2，即912
```

执行用时 :2 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗 :40.2 MB, 在所有 Java 提交中击败了100.00%的用户

```java
//进阶问题，直接分别扫描，把数值装入stack，然后从stack中取值，跟下面方法一样。
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode root=new ListNode(-1);
        ListNode cur=root;
        ListNode node1=l1;
        ListNode node2=l2;
        int temp=0;
        int sum=0;
        while(node1!=null&&node2!=null){
            sum=node1.val+node2.val+temp;
            cur.next=new ListNode(sum%10);
            cur=cur.next;
            temp=sum/10;
            node1=node1.next;
            node2=node2.next;
        }
        if(node1==null){
            while(node2!=null){
                sum=node2.val+temp;
            cur.next=new ListNode(sum%10);
            cur=cur.next;
            temp=sum/10;
            node2=node2.next;
            }
        }
        if(node2==null){
            while(node1!=null){
                sum=node1.val+temp;
            cur.next=new ListNode(sum%10);
            cur=cur.next;
            temp=sum/10;
            node1=node1.next;
            }
        }
        if(temp!=0){
            cur.next=new ListNode(temp);
        }
        return root.next;
    }
}
```

#### [面试题 02.06. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list-lcci/)

###### 未作出进阶

难度简单17收藏分享切换为英文关注反馈

编写一个函数，检查输入的链表是否是回文的。

**示例 1：**

```
输入： 1->2
输出： false 
```

**示例 2：**

```
输入： 1->2->2->1
输出： true 
```

**进阶：**
**你能否用 O(n) 时间复杂度和 O(1) 空间复杂度**解决此题？

解决思想
由于无法知道节点的前一个节点，一个比较好想到的方法就是翻转链表，然后再去比较原链表与翻转后的链表。

翻转链表：

![屏幕快照 2020-06-11 23.30.01.png](https://pic.leetcode-cn.com/9855a4dbcb091961bf390652e22d3521b9f40a146ae153a5864e0d8cf482c601-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202020-06-11%2023.30.01.png)


但是直接的使用翻转链表会耗费空间去储存链表。

可以使用快慢指针，找到中间链表的中间位置mid，mid之前的节点进行翻转得到left链表，之后的节点保持不变得到right链表，在比较两个链表。

快慢指针(偶数)：

![屏幕快照 2020-06-11 23.30.08.png](https://pic.leetcode-cn.com/3f1feec75c087d4630740e199a72b681b53af1191c6f48c3e4f37354f0985e36-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202020-06-11%2023.30.08.png)

快慢指针(奇数)：

![屏幕快照 2020-06-11 23.30.18.png](https://pic.leetcode-cn.com/e9fffbda29097722c7ec6cecb13e8d5e2073801561a20045092dea8fb368ddc6-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202020-06-11%2023.30.18.png)

执行用时 :1 ms, 在所有 Java 提交中击败了99.96%的用户

内存消耗 :42.3 MB, 在所有 Java 提交中击败了100.00%的用户

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        if(head==null||head.next==null)return true;
        ListNode dumyNode=new ListNode(-1);
        dumyNode.next=head;
        ListNode slow=dumyNode;
        ListNode fast=dumyNode;
        ListNode pre=null;
        // 使用快慢指针找到链表的中间位置，并翻转慢指针前的链表
        while(fast!=null&&fast.next!=null){
            fast=fast.next.next;
            ListNode temp=slow.next;
            slow.next=pre;
            pre=slow;
            slow=temp;
        }
        ListNode right;
        if(fast!=null){
            // 不为空，表示链表size为偶数
            if(slow.val!=slow.next.val){
                return false;
            }
            right=slow.next.next;
        }else{
            right=slow.next;
        } 
        while(pre!=null&&right!=null){
            if(pre.val!=right.val){
                return false;
            }
            pre=pre.next;
            right=right.next;
        }
        return true;
    }
}
```

#### [面试题 02.07. 链表相交](https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/)

难度简单21收藏分享切换为英文关注反馈

给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第k个节点与另一个链表的第j个节点是同一节点（引用完全相同），则这两个链表相交。

**示例 1：**

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
```

**示例 2：**

```
输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Reference of the node with value = 2
输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
```

**示例 3：**

```
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
解释：这两个链表不相交，因此返回 null。
```

**注意：**

- 如果两个链表没有交点，返回 `null` 。
- 在返回结果后，两个链表仍须保持原有的结构。
- 可假定整个链表结构中没有循环。
- 程序尽量满足 O(*n*) 时间复杂度，且仅用 O(*1*) 内存。

执行用时 :1 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗 :42.7 MB, 在所有 Java 提交中击败了100.00%的用户

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode node1=headA;
        ListNode node2=headB;
        int count=0;
        while(node1!=null){
            node1=node1.next;
            count++;
        }
        while(node2!=null){
            node2=node2.next;
            count--;
        }
        node1=headB;
        node2=headA;
        if(count>=0){
            while(count!=0){
                node2=node2.next;
                count--;
            }
        }else{
            while(count!=0){
                node1=node1.next;
                count++;
            }
        }
        while(node1!=node2){
            node1=node1.next;
            node2=node2.next;
        }
        if(node1==null){
            return null;
        }
        return node1;
    }
}
```

## 2020/6/29

#### [面试题 02.08. 环路检测](https://leetcode-cn.com/problems/linked-list-cycle-lcci/)

难度中等18收藏分享切换为英文关注反馈

给定一个有环链表，实现一个算法返回环路的开头节点。
有环链表的定义：在链表中某个节点的next元素指向在它前面出现过的节点，则表明该链表存在环路。

**示例 1：**

```
输入：head = [3,2,0,-4], pos = 1
输出：tail connects to node index 1
解释：链表中有一个环，其尾部连接到第二个节点。
```

**示例 2：**

```
输入：head = [1,2], pos = 0
输出：tail connects to node index 0
解释：链表中有一个环，其尾部连接到第一个点。
```

**示例 3：**

```
输入：head = [1], pos = -1
输出：no cycle
解释：链表中没有环。
```

**进阶：**
你是否可以**不用额外空间**解决此题？

执行用时 :0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗 :40.1 MB, 在所有 Java 提交中击败了100.00%的用户

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if(head==null||head.next==null)return null;
        ListNode slow=head;
        ListNode fast=head;
        while(fast.next!=null&&fast.next.next!=null){
            slow=slow.next;
            fast=fast.next.next;
            if(fast==slow){
                break;
            }
        }
        if(fast.next==null||fast.next.next==null) return null;
        slow=head;
        while(slow!=fast){
            slow=slow.next;
            fast=fast.next;
        }
        return slow;
    }
}
```

#### [面试题 03.01. 三合一](https://leetcode-cn.com/problems/three-in-one-lcci/)

难度简单9收藏分享切换为英文关注反馈

三合一。描述如何只用一个数组来实现三个栈。

你应该实现`push(stackNum, value)`、`pop(stackNum)`、`isEmpty(stackNum)`、`peek(stackNum)`方法。`stackNum`表示栈下标，`value`表示压入的值。

构造函数会传入一个`stackSize`参数，代表每个栈的大小。

**示例1:**

```
 输入：
["TripleInOne", "push", "push", "pop", "pop", "pop", "isEmpty"]
[[1], [0, 1], [0, 2], [0], [0], [0], [0]]
 输出：
[null, null, null, 1, -1, -1, true]
说明：当栈为空时`pop, peek`返回-1，当栈满时`push`不压入元素。
```

**示例2:**

```
 输入：
["TripleInOne", "push", "push", "push", "pop", "pop", "pop", "peek"]
[[2], [0, 1], [0, 2], [0, 3], [0], [0], [0], [0]]
 输出：
[null, null, null, null, 2, 1, -1, -1]
```

执行用时 :12 ms, 在所有 Java 提交中击败了99.72%的用户

内存消耗 :48.7 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class TripleInOne {
    int[] a;
    int stackSize;
    int[] index=new int[3];
    public TripleInOne(int stackSize) {
        a=new int[stackSize*3];
        this.stackSize=stackSize;
    }
    
    public void push(int stackNum, int value) {
        if(index[stackNum]==stackSize){
            return;
        }else{
            a[stackNum*stackSize+index[stackNum]]=value;
            index[stackNum]+=1;
            return;
        }
    }
    
    public int pop(int stackNum) {
        if(index[stackNum]==0){
            return -1;
        }else{
            int temp=a[stackNum*stackSize+index[stackNum]-1];
            index[stackNum]-=1;
            return temp;
            
            
        }
    }
    
    public int peek(int stackNum) {
        if(index[stackNum]==0){
            return -1;
        }else{
            return a[stackNum*stackSize+index[stackNum]-1];
        }
    }
    
    public boolean isEmpty(int stackNum) {
        if(index[stackNum]==0){
            return true;
        }
        return false;
    }
}

/**
 * Your TripleInOne object will be instantiated and called as such:
 * TripleInOne obj = new TripleInOne(stackSize);
 * obj.push(stackNum,value);
 * int param_2 = obj.pop(stackNum);
 * int param_3 = obj.peek(stackNum);
 * boolean param_4 = obj.isEmpty(stackNum);
 */
```

#### [面试题 03.02. 栈的最小值](https://leetcode-cn.com/problems/min-stack-lcci/)

###### 用LinkedList比用Stack来当stack用，快很多？？？

难度简单17收藏分享切换为英文关注反馈

请设计一个栈，除了常规栈支持的pop与push函数以外，还支持min函数，该函数返回栈元素中的最小值。执行push、pop和min操作的时间复杂度必须为O(1)。

**示例：**

```
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

执行用时 :18 ms, 在所有 Java 提交中击败了97.59%的用户

内存消耗 :41.1 MB, 在所有 Java 提交中击败了100.00%的用户

```java
//用双栈不如用单栈加一个min指示器
//用LinkedList比用Stack来当stack用，快很多？？？
class MinStack {

    LinkedList<Integer> stack;
    int min = Integer.MAX_VALUE;

    /** initialize your data structure here. */
    public MinStack() {
        stack = new LinkedList<>();
    }
    
    public void push(int x) {
        if(x > min){
            stack.push(x);
        } else{
            stack.push(min);
            stack.push(x);
            min = x;
        }
    }
    
    public void pop() {
        if(stack.peek() > min){
            stack.poll();
        } else{
            stack.poll();
            min = stack.poll();
        }
    }
    
    public int top() {
        return stack.peek();
    }
    
    public int getMin() {
        return min;
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(x);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */

```

#### [面试题 03.03. 堆盘子](https://leetcode-cn.com/problems/stack-of-plates-lcci/)

###### ArrayList中set 方法 只能替换数组中已经存在的元素内容(设置原来没有的索引处会越界)add(index,param)方法会导致原来此索引的元素向后移，切记

难度中等5收藏分享切换为英文关注反馈

堆盘子。设想有一堆盘子，堆太高可能会倒下来。因此，在现实生活中，盘子堆到一定高度时，我们就会另外堆一堆盘子。请实现数据结构`SetOfStacks`，模拟这种行为。`SetOfStacks`应该由多个栈组成，并且在前一个栈填满时新建一个栈。此外，`SetOfStacks.push()`和`SetOfStacks.pop()`应该与普通栈的操作方法相同（也就是说，pop()返回的值，应该跟只有一个栈时的情况一样）。 进阶：实现一个`popAt(int index)`方法，根据指定的子栈，执行pop操作。

当某个栈为空时，应当删除该栈。当栈中没有元素或不存在该栈时，`pop`，`popAt` 应返回 -1.

**示例1:**

```
 输入：
["StackOfPlates", "push", "push", "popAt", "pop", "pop"]
[[1], [1], [2], [1], [], []]
 输出：
[null, null, null, 2, 1, -1]
```

**示例2:**

```
 输入：
["StackOfPlates", "push", "push", "push", "popAt", "popAt", "popAt"]
[[2], [1], [2], [3], [0], [0], [0]]
 输出：
[null, null, null, null, 2, 1, 3]
```

因为此题至少锻炼把想法写成代码的能力，算法思想设计较少，时间有限就不优化了

执行用时 :15 ms, 在所有 Java 提交中击败了55.16%的用户

内存消耗 :47.6 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class StackOfPlates {
    ArrayList<Stack<Integer>> result=new ArrayList<Stack<Integer>>();
    ArrayList<Integer> size=new ArrayList<>();
    int cap;
    public StackOfPlates(int cap) {
        this.cap=cap;
    }
    
    public void push(int val) {
        if(cap==0)return;
        int reSize=size.size();
        if(reSize==0){
            Stack<Integer> stack=new Stack<>();
            stack.push(val);
            result.add(stack);
            size.add(0,1);
        }else{
            if(size.get(reSize-1)<cap){
                Stack<Integer> stack=result.get(reSize-1);
                stack.push(val);
                result.set(reSize-1,stack);
                size.set(reSize-1,size.get(reSize-1)+1);
            }else{
                Stack<Integer> stack=new Stack<>();
                stack.push(val);
                result.add(reSize,stack);
                size.add(reSize,1);
            }
        }
    }
    
    public int pop() {
        if(cap==0)return -1;
        int reSize=size.size();
        int res=0;
        if(reSize==0){
            return -1;
        }else{
            if(size.get(reSize-1)>1){
                Stack<Integer> stack=result.get(reSize-1);
                res=stack.pop();
                result.set(reSize-1,stack);
                size.set(reSize-1,size.get(reSize-1)-1);
                return res;
            }else{
                Stack<Integer> stack=result.get(reSize-1);
                res=stack.pop();
                result.remove(reSize-1);
                size.remove(reSize-1);
                return res;
            }
        }
    }
    
    public int popAt(int index) {
        if(cap==0)return -1;
        int reSize=size.size();
        int res=0;
        if(reSize==0||index>=reSize){
            return -1;
        }else{
            if(size.get(index)>1){
                Stack<Integer> stack=result.get(index);
                res=stack.pop();
                result.set(index,stack);
                size.set(index,size.get(index)-1);
                return res;
            }else{
                Stack<Integer> stack=result.get(index);
                res=stack.pop();
                result.remove(index);
                size.remove(index);
                return res;
            }
        }
    }
}

/**
 * Your StackOfPlates object will be instantiated and called as such:
 * StackOfPlates obj = new StackOfPlates(cap);
 * obj.push(val);
 * int param_2 = obj.pop();
 * int param_3 = obj.popAt(index);
 */
```

## 2020/6/30

#### [面试题 03.04. 化栈为队](https://leetcode-cn.com/problems/implement-queue-using-stacks-lcci/)

难度简单15收藏分享切换为英文关注反馈

实现一个MyQueue类，该类用两个栈来实现一个队列。

**示例：**

```
MyQueue queue = new MyQueue();

queue.push(1);
queue.push(2);
queue.peek();  // 返回 1
queue.pop();   // 返回 1
queue.empty(); // 返回 false
```

**说明：**

- 你只能使用标准的栈操作 -- 也就是只有 `push to top`, `peek/pop from top`, `size` 和 `is empty` 操作是合法的。
- 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
- 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。

执行用时：12 ms, 在所有 Java 提交中击败了98.33%的用户

内存消耗：37.2 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class MyQueue {
    Stack<Integer> stack1=new Stack<Integer>();
    Stack<Integer> stack2=new Stack<Integer>();
    /** Initialize your data structure here. */
    public MyQueue() {

    }
    
    /** Push element x to the back of queue. */
    public void push(int x) {
        stack1.push(x);
    }
    
    /** Removes the element from in front of queue and returns that element. */
    public int pop() {
        if(!stack2.isEmpty()){
            return stack2.pop();
        }else{
            if(!stack1.isEmpty()){
                while(!stack1.isEmpty()){
                    stack2.push(stack1.pop());
                }
                return stack2.pop();
            }
        }
        return stack2.pop();
    }
    
    /** Get the front element. */
    public int peek() {
        if(!stack2.isEmpty()){
            return stack2.peek();
        }else{
            if(!stack1.isEmpty()){
                while(!stack1.isEmpty()){
                    stack2.push(stack1.pop());
                }
                return stack2.peek();
            }
        }
        return stack2.peek();
    }
    
    /** Returns whether the queue is empty. */
    public boolean empty() {
        if(!stack2.isEmpty()||!stack1.isEmpty()){
            return false;
        }
        return true;
    }
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = new MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * boolean param_4 = obj.empty();
 */
```

#### [面试题 03.05. 栈排序](https://leetcode-cn.com/problems/sort-of-stacks-lcci/)

难度中等11收藏分享切换为英文关注反馈

栈排序。 编写程序，对栈进行排序使最小元素位于栈顶。最多只能使用一个其他的临时栈存放数据，但不得将元素复制到别的数据结构（如数组）中。该栈支持如下操作：`push`、`pop`、`peek` 和 `isEmpty`。当栈为空时，`peek` 返回 -1。

**示例1:**

```
 输入：
["SortedStack", "push", "push", "peek", "pop", "peek"]
[[], [1], [2], [], [], []]
 输出：
[null,null,null,1,null,2]
```

**示例2:**

```
 输入： 
["SortedStack", "pop", "pop", "push", "pop", "isEmpty"]
[[], [], [], [1], [], []]
 输出：
[null,null,null,null,null,true]
```

**说明:**

1. 栈中的元素数目在[0, 5000]范围内

执行用时：207 ms, 在所有 Java 提交中击败了52.46%的用户

内存消耗：39.8 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class SortedStack {
    Stack<Integer> stack1=new Stack<>();
    Stack<Integer> stack2=new Stack<>();
    public SortedStack() {

    }
    
    public void push(int val) {
        if(stack1.isEmpty()){
            stack1.push(val);
        }else{
            int top=stack1.peek();
            if(top>=val){
                stack1.push(val);
            }else{
                while(!stack1.isEmpty()&&stack1.peek()<val){
                    stack2.push(stack1.pop());
                }
                stack1.push(val);
                while(!stack2.isEmpty()){
                    stack1.push(stack2.pop());
                }
            }
        }
    }
    
    public void pop() {
        if(stack1.isEmpty()){
            return;
        }
        stack1.pop();
    }
    
    public int peek() {
        if(stack1.isEmpty()){
            return -1;
        }
        return stack1.peek();
    }
    
    public boolean isEmpty() {
        if(stack1.isEmpty()){
            return true;
        }
        return false;
    }
}

/**
 * Your SortedStack object will be instantiated and called as such:
 * SortedStack obj = new SortedStack();
 * obj.push(val);
 * obj.pop();
 * int param_3 = obj.peek();
 * boolean param_4 = obj.isEmpty();
 */
```

#### [面试题 03.06. 动物收容所](https://leetcode-cn.com/problems/animal-shelter-lcci/)

难度简单5收藏分享切换为英文关注反馈

动物收容所。有家动物收容所只收容狗与猫，且严格遵守“先进先出”的原则。在收养该收容所的动物时，收养人只能收养所有动物中“最老”（由其进入收容所的时间长短而定）的动物，或者可以挑选猫或狗（同时必须收养此类动物中“最老”的）。换言之，收养人不能自由挑选想收养的对象。请创建适用于这个系统的数据结构，实现各种操作方法，比如`enqueue`、`dequeueAny`、`dequeueDog`和`dequeueCat`。允许使用Java内置的LinkedList数据结构。

`enqueue`方法有一个`animal`参数，`animal[0]`代表动物编号，`animal[1]`代表动物种类，其中 0 代表猫，1 代表狗。

`dequeue*`方法返回一个列表`[动物编号, 动物种类]`，若没有可以收养的动物，则返回`[-1,-1]`。

**示例1:**

```
 输入：
["AnimalShelf", "enqueue", "enqueue", "dequeueCat", "dequeueDog", "dequeueAny"]
[[], [[0, 0]], [[1, 0]], [], [], []]
 输出：
[null,null,null,[0,0],[-1,-1],[1,0]]
```

**示例2:**

```
 输入：
["AnimalShelf", "enqueue", "enqueue", "enqueue", "dequeueDog", "dequeueCat", "dequeueAny"]
[[], [[0, 0]], [[1, 0]], [[2, 1]], [], [], []]
 输出：
[null,null,null,null,[2,1],[0,0],[1,0]]
```

**说明:**

1. 收纳所的最大容量为20000

执行用时：111 ms, 在所有 Java 提交中击败了22.73%的用户

内存消耗：49.5 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class AnimalShelf {
    LinkedList<int[]> list1=new LinkedList<>();
    LinkedList<int[]> list2=new LinkedList<>();
    LinkedList<Integer> index1=new LinkedList<>();
    LinkedList<Integer> index2=new LinkedList<>();
    int count=0;
    public AnimalShelf() {

    }
    
    public void enqueue(int[] animal) {
        if(animal[1]==0){
            list1.add(animal);
            index1.add(count++);
        }else{
            list2.add(animal);
            index2.add(count++);
        }

    }
    
    public int[] dequeueAny() {
        int a=index1.size();
        int b=index2.size();
        if(a!=0&&b!=0){
            if(index1.peek()<index2.peek()){
                index1.remove();
                return list1.remove();
            }else{
                index2.remove();
                return list2.remove();
            }
        }else if(a!=0){
            index1.remove();
            return list1.remove();
        }else if(b!=0){
            index2.remove();
            return list2.remove();
        }else{
            return new int[]{-1,-1};
        }
    }
    
    public int[] dequeueDog() {
        if(index2.size()!=0){
            index2.remove();
            return list2.remove();
        }
        return new int[]{-1,-1};
    }
    
    public int[] dequeueCat() {
        if(index1.size()!=0){
            index1.remove();
            return list1.remove();
        }
        return new int[]{-1,-1};
    }
}

/**
 * Your AnimalShelf object will be instantiated and called as such:
 * AnimalShelf obj = new AnimalShelf();
 * obj.enqueue(animal);
 * int[] param_2 = obj.dequeueAny();
 * int[] param_3 = obj.dequeueDog();
 * int[] param_4 = obj.dequeueCat();
 */
```

#### [面试题 04.01. 节点间通路](https://leetcode-cn.com/problems/route-between-nodes-lcci/)

难度中等8收藏分享切换为英文关注反馈

节点间通路。给定有向图，设计一个算法，找出两个节点之间是否存在一条路径。

**示例1:**

```
 输入：n = 3, graph = [[0, 1], [0, 2], [1, 2], [1, 2]], start = 0, target = 2
 输出：true
```

**示例2:**

```
 输入：n = 5, graph = [[0, 1], [0, 2], [0, 4], [0, 4], [0, 1], [1, 3], [1, 4], [1, 3], [2, 3], [3, 4]], start = 0, target = 4
 输出 true
```

**提示：**

1. 节点数量n在[0, 1e5]范围内。
2. 节点编号大于等于 0 小于 n。
3. 图中可能存在自环和平行边。

执行用时：27 ms, 在所有 Java 提交中击败了61.64%的用户

内存消耗：84.6 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    public boolean findWhetherExistsPath(int n, int[][] graph, int start, int target) {
       if(start==target)return true;
       Map<Integer,ArrayList<Integer>> map=new HashMap<>();
       boolean[] visited=new boolean[n];
       int m=graph.length;
       int i=0;
       while(i<m){
           int num=graph[i][0];
           ArrayList<Integer> list=new ArrayList<>();
           while(i<m&&graph[i][0]==num){
               list.add(graph[i][1]);
               i++;
           }
           map.put(num,list);
       }
       LinkedList<Integer> queue=new LinkedList<>();
       queue.addFirst(start);
       visited[start]=true;
       while(!queue.isEmpty()){
           int temp=queue.removeFirst();
           if(map.get(temp)==null){
               continue;
           }else{
               ArrayList<Integer> list=map.get(temp);
               int m1=list.size();
               //此处不能把visited[res]的判断放在for循环中m1的后面，那样会导致判决成功后直接跳出，导致后面的元素没法加入；
               for(i=0;i<m1;i++){
                   int res=list.get(i);
                   if(visited[res])continue;
                   if(res==target) return true;
                   queue.addLast(res);
                   visited[res]=true;
               }
           }
       }
       return false;
    }
}
```

#### [面试题 04.02. 最小高度树](https://leetcode-cn.com/problems/minimum-height-tree-lcci/)

难度简单33收藏分享切换为英文关注反馈

给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。

**示例:**

```
给定有序数组: [-10,-3,0,5,9],

一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：

          0 
         / \ 
       -3   9 
       /   / 
     -10  5 
```

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：40 MB, 在所有 Java 提交中击败了100.00%的用户

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    int[] nums;
    public TreeNode sortedArrayToBST(int[] nums) {
        this.nums=nums;
        if(nums.length==0)return null;
        int n=nums.length;
        return build(0,n-1);
    }
    public TreeNode build(int l,int r){
        if(l>r)return null;
        int mid=(r-l)/2+l;//此处忘了加l，不加的话就不是mid，而是2端值的差的一半了，加上起始索引，才能引用正确的nums[mid]，
        TreeNode node=new TreeNode(nums[mid]);
        TreeNode left=build(l,mid-1);
        TreeNode right=build(mid+1,r);
        node.left=left;
        node.right=right;
        return node;
    }
    
}
```

## 2020/7/1

#### [面试题 04.03. 特定深度节点链表](https://leetcode-cn.com/problems/list-of-depth-lcci/)

难度中等11收藏分享切换为英文关注反馈

给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表（比如，若一棵树的深度为 `D`，则会创建出 `D` 个链表）。返回一个包含所有深度的链表的数组。

**示例：**

```
输入：[1,2,3,4,5,null,7,8]

        1
       /  \ 
      2    3
     / \    \ 
    4   5    7
   /
  8

输出：[[1],[2,3],[4,5,7],[8]]
```

执行用时：1 ms, 在所有 Java 提交中击败了98.71%的用户

内存消耗：38.1 MB, 在所有 Java 提交中击败了100.00%的用户

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode[] listOfDepth(TreeNode tree) {
        if(tree==null)return new ListNode[0];
        LinkedList<TreeNode> queue=new LinkedList<>();
        queue.add(tree);
        ArrayList<ListNode> list=new ArrayList<>();
        int count=0;
        while(!queue.isEmpty()){
            int size=queue.size();
            ListNode node=new ListNode(-1);
            ListNode temp=node;
            for(int i=0;i<size;i++){
                TreeNode tree2=queue.removeFirst();
                if(tree2.left!=null){
                    queue.addLast(tree2.left);
                }
                if(tree2.right!=null){
                    queue.addLast(tree2.right);
                }
                temp.next=new ListNode(tree2.val);
                temp=temp.next;
            }
            list.add(count,node.next);
            count++;
        }
        return list.toArray(new ListNode[count]);
    }
}
```

#### [面试题 04.04. 检查平衡性](https://leetcode-cn.com/problems/check-balance-lcci/)

###### 未作出

难度简单23收藏分享切换为英文关注反馈

实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个节点，其两棵子树的高度差不超过 1。
**示例 1:**

```
给定二叉树 [3,9,20,null,null,15,7]
    3
   / \
  9  20
    /  \
   15   7
返回 true 。
```

**示例 2:**

```
给定二叉树 [1,2,2,3,3,null,null,4,4]
      1
     / \
    2   2
   / \
  3   3
 / \
4   4
返回 false 。
```

执行用时：1 ms, 在所有 Java 提交中击败了99.96%的用户

内存消耗：39.8 MB, 在所有 Java 提交中击败了100.00%的用户

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isBalanced(TreeNode root) {
        return root==null?true:(Math.abs(depth(root.left)-depth(root.right))<2&&isBalanced(root.left)&&isBalanced(root.right));
        
    }
    public int depth(TreeNode root){
        return root==null?0:Math.max(depth(root.left),depth(root.right))+1;
    }
}
class Solution {
    boolean flag = true;
    public boolean isBalanced(TreeNode root) {
        dfs(root);
        return flag;
    }
    public int dfs(TreeNode root){
        if(root == null) return 0;
        int left = dfs(root.left);
        int right = dfs(root.right);
        if(Math.abs(left-right) > 1){
            flag = false;
        }
        return Math.max(left,right) + 1;
    }
}
```

#### [面试题 04.05. 合法二叉搜索树](https://leetcode-cn.com/problems/legal-binary-search-tree-lcci/)

难度中等20收藏分享切换为英文关注反馈

实现一个函数，检查一棵二叉树是否为二叉搜索树。

**示例 1:**

```
输入:
    2
   / \
  1   3
输出: true
```

**示例 2:**

```
输入:
    5
   / \
  1   4
     / \
    3   6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
     根节点的值为 5 ，但是其右子节点值为 4 。
```

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：39.3 MB, 在所有 Java 提交中击败了100.00%的用户

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isValidBST(TreeNode root) {
        if(root==null)return true;
        TreeNode maxLeft=root.left,minRight=root.right;
        while(maxLeft!=null&&maxLeft.right!=null){
            maxLeft=maxLeft.right;
        }
        while(minRight!=null&&minRight.left!=null){
            minRight=minRight.left;
        }
        boolean res=(maxLeft==null||maxLeft.val<root.val)&&(minRight==null||minRight.val>root.val);
        return res&&isValidBST(root.left)&&isValidBST(root.right);
    }
    
}
```

#### [面试题 04.06. 后继者](https://leetcode-cn.com/problems/successor-lcci/)

难度中等19收藏分享切换为英文关注反馈

设计一个算法，找出二叉搜索树中指定节点的“下一个”节点（也即中序后继）。

如果指定节点没有对应的“下一个”节点，则返回`null`。

**示例 1:**

```
输入: root = [2,1,3], p = 1

  2
 / \
1   3

输出: 2
```

**示例 2:**

```
输入: root = [5,3,6,2,4,null,null,1], p = 6

      5
     / \
    3   6
   / \
  2   4
 /   
1

输出: null
```

执行用时：3 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：40.3 MB, 在所有 Java 提交中击败了100.00%的用户

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    
    //传root值的开关
    boolean flag = false;
    //存储后继节点
    TreeNode aimNode;
    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
        if(root==null){
            return aimNode;
        }
        //下面所有代码是正常中序顺序的步骤
       inorderSuccessor(root.left,p);
       if(root==p){
           //找到p节点，打开开关
           flag = true;
       }else if(flag){
           //root不为p，且开关被打开时，才能进入此处
           //传出这个后继节点
           aimNode = root;
           flag =false;
       }
       inorderSuccessor(root.right,p);
       return aimNode;
    }
}
```

## 2020/7/2

#### [面试题 04.08. 首个共同祖先](https://leetcode-cn.com/problems/first-common-ancestor-lcci/)

###### 未作出

难度中等13收藏分享切换为英文关注反馈

设计并实现一个算法，找出二叉树中某两个节点的第一个共同祖先。不得将其他的节点存储在另外的数据结构中。注意：这不一定是二叉搜索树。

例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]

```
    3
   / \
  5   1
 / \ / \
6  2 0  8
  / \
 7   4
```

**示例 1:**

```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3。
```

**示例 2:**

```
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。
```

**说明:**

```
所有节点的值都是唯一的。
p、q 为不同节点且均存在于给定的二叉树中。
```

执行用时：9 ms, 在所有 Java 提交中击败了29.21%的用户

内存消耗：42.2 MB, 在所有 Java 提交中击败了100.00%的用户

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
       if(root==null||root==p||root==q)return root;
       TreeNode left=lowestCommonAncestor(root.left,p,q);
       TreeNode right=lowestCommonAncestor(root.right,p,q);
       if(left!=null&&right!=null){
           return root;
       }else if(left==null){
           return right;
       }else{
           return left;
       }
    }
}
class Solution {
    private TreeNode res;
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        this.res=null;
        if(root==null) return res;
        help(root,p,q);
        return res;
    }
    private boolean help(TreeNode root,TreeNode p,TreeNode q){
        if(root==null){
            return false;
        }
        int left=(help(root.left,p,q))?1:0;
        int right=(help(root.right,p,q))?1:0;
        int mid=(root==p||root==q)?1:0;
        if(mid+left+right>=2){
            this.res=root;
        }
        return (mid+left+right)>0;
    }
}
```

#### [面试题 04.09. 二叉搜索树序列](https://leetcode-cn.com/problems/bst-sequences-lcci/)

难度困难24收藏分享切换为英文关注反馈

从左向右遍历一个数组，通过不断将其中的元素插入树中可以逐步地生成一棵二叉搜索树。给定一个由不同节点组成的二叉树，输出所有可能生成此树的数组。

**示例:**
给定如下二叉树

```
        2
       / \
      1   3
```

返回:

```
[
   [2,1,3],
   [2,3,1]
]
```

能够生成同一二叉树的所有不同序列————这一题乍一看就是全排列问题，而全排列的套路无外乎递归三板斧：

```java
//定义好结果集
List<...> res = ...
void dfs(int level,...){
    //1.设定终止条件
    if(level达到遍历的最高层数) ....return;
//2.对当前层数能够访问的元素进行遍历
for(){
    ...
    //3.1 最关键的一步，设定访问标记，防止重复访问
    dfs(level+1,访问标记数组);
    //3.2 擦除访问标记
}
```

再回到该题，我们会发现和一般的全排列是有一些区别的————加了一些额外的限定条件，即任一节点root的子节点必须再该节点之后访问，比如：


```java
 	2
   / \
  1   3
       \
        4
```
显然树中的节点满足了偏序关系（自反，传递，反对称），1和3因为与2相连，所以(1,3)必须在2后面，同理4和3相连所以4必须放在3后面，同时4与2具有传递性，因此4也必须在2后面。而4与1无直接或传递关系，所以可以乱序。

搞明白这一点，我们只需要将下一层能够遍历的元素找出即可。比如我们当前遍历到了3的位置，那下一层能遍历的节点只有两类：和当前节点无偏序关系的兄弟节点(1)以及一定排在当前节点后面的子节点(4)，那么下一层能够遍历的就为（1，4）。而具体的概括就是

同一层能够遍历的元素curSet是不存在依赖关系的
从curSet中的root出发，下一层的能够遍历的节点为curSet-{root}+{root.left,root.right}。

执行用时：11 ms, 在所有 Java 提交中击败了32.69%的用户

内存消耗：43.3 MB, 在所有 Java 提交中击败了100.00%的用户

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    List<List<Integer>> list1=new LinkedList<>();
    LinkedList<Integer> list2=new LinkedList<>();
    public List<List<Integer>> BSTSequences(TreeNode root) {
        if(root==null) {
            list1.add(list2); 
            return list1;
        }
        HashSet<TreeNode> curLever=new HashSet<>();
        curLever.add(root);
        dfs(curLever);
        return list1;
    }
    private void dfs(HashSet<TreeNode> curLever){
        if(curLever.size()==0){
            list1.add(new LinkedList<>(list2));
            return;
        }
        HashSet<TreeNode> nextLever=new HashSet<>(curLever);
        for(TreeNode node:curLever){
            list2.add(node.val);
            nextLever.remove(node);
            if(node.left!=null)nextLever.add(node.left);
            if(node.right!=null)nextLever.add(node.right);
            dfs(nextLever);
            if(node.left!=null)nextLever.remove(node.left);
            if(node.right!=null)nextLever.remove(node.right);
            nextLever.add(node);
            list2.removeLast();
           
        }
    }
}
```

#### [面试题 04.10. 检查子树](https://leetcode-cn.com/problems/check-subtree-lcci/)

难度中等13收藏分享切换为英文关注反馈

检查子树。你有两棵非常大的二叉树：T1，有几万个节点；T2，有几万个节点。设计一个算法，判断 T2 是否为 T1 的子树。

如果 T1 有这么一个节点 n，其子树与 T2 一模一样，则 T2 为 T1 的子树，也就是说，从节点 n 处把树砍断，得到的树与 T2 完全相同。

**示例1:**

```
 输入：t1 = [1, 2, 3], t2 = [2]
 输出：true
```

**示例2:**

```
 输入：t1 = [1, null, 2, 4], t2 = [3, 2]
 输出：false
```

**提示：**

1. 树的节点数目范围为[0, 20000]。

执行用时：1 ms, 在所有 Java 提交中击败了95.85%的用户

内存消耗：42.5 MB, 在所有 Java 提交中击败了100.00%的用户

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean checkSubTree(TreeNode t1, TreeNode t2) {
        if(t2==null)return true;
        if(t1==null&&t2!=null)return false;
        if(t1.val==t2.val){
            return checkSubTree(t1.left,t2.left)&&checkSubTree(t1.right,t2.right);
        }
        return checkSubTree(t1.left,t2)||checkSubTree(t1.right,t2);
    }
}
```

#### [面试题 04.12. 求和路径](https://leetcode-cn.com/problems/paths-with-sum-lcci/)

###### 未作出

难度中等22收藏分享切换为英文关注反馈

给定一棵二叉树，其中每个节点都含有一个整数数值(该值或正或负)。设计一个算法，打印节点数值总和等于某个给定值的所有路径的数量。注意，路径不一定非得从二叉树的根节点或叶节点开始或结束，但是其方向必须向下(只能从父节点指向子节点方向)。

**示例:**
给定如下二叉树，以及目标和 `sum = 22`，

```
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
```

返回:

```
3
解释：和为 22 的路径有：[5,4,11,2], [5,8,4,5], [4,11,7]
```

提示：

- `节点总数 <= 10000`

执行用时：2 ms, 在所有 Java 提交中击败了86.96%的用户//第三种方法

内存消耗：39.8 MB, 在所有 Java 提交中击败了100.00%的用户

解题思路
这道题用到了一个概念，叫前缀和。就是到达当前元素的路径上，之前所有元素的和。

前缀和怎么应用呢？

如果两个数的**前缀总和是相同的**，那么这些节点之间的**元素总和为零**。进一步扩展相同的想法，如果前缀总和currSum，在节点A和节点B处相差target，则位于节点A和节点B之间的元素之和是target。

因为本题中的路径是一棵树，从根往任一节点的路径上(不走回头路)，**有且仅有一条路径，因为不存在环**。(如果存在环，前缀和就不能用了，需要改造算法)

抵达当前节点(即B节点)后，将前缀和累加，然后查找在前缀和上，有没有前缀和**currSum-target**的节点(即A节点)，存在即表示从A到B有一条路径之和满足条件的情况。结果加上满足前缀和**currSum-target**的节点的数量。然后递归进入左右子树。

左右子树遍历完成之后，回到当前层，需要把当前节点添加的前缀和去除。避免回溯之后影响上一层。因为思想是前缀和，不属于前缀的，我们就要去掉它。

```java
1//错的，不知道为什么
class Solution {
    public int pathSum(TreeNode root, int sum) {
        if(root==null)return 0;
        if(root.val==sum){
            return pathSum(root.left,sum)+pathSum(root.right,sum)+1+
            pathSum(root.left,sum-root.val)+pathSum(root.right,sum-root.val);
        }else{
            return pathSum(root.left,sum-root.val)+pathSum(root.right,sum-root.val)+
            pathSum(root.left,sum)+pathSum(root.right,sum);
        }
    }
}
2//51%基础解法
class Solution {
    public int pathSum(TreeNode root, int sum) {
        if(root==null)return 0;
        return help(root,sum)+pathSum(root.left,sum)+pathSum(root.right,sum);
    }
    private int help(TreeNode root,int sum){
        if(root==null)return 0;
        int ret=0;
        if(root.val==sum) ret++;
        ret+=help(root.left,sum-root.val)+help(root.right,sum-root.val);
        return ret;
    }
}
3//
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int pathSum(TreeNode root, int sum) {
        // key是前缀和, value是大小为key的前缀和出现的次数
        Map<Integer, Integer> prefixSumCount = new HashMap<>();
        // 前缀和为0的一条路径
        prefixSumCount.put(0, 1);
        // 前缀和的递归回溯思路
        return recursionPathSum(root, prefixSumCount, sum, 0);
    }

    /**
     * 前缀和的递归回溯思路
     * 从当前节点反推到根节点(反推比较好理解，正向其实也只有一条)，有且仅有一条路径，因为这是一棵树
     * 如果此前有和为currSum-target,而当前的和又为currSum,两者的差就肯定为target了
     * 所以前缀和对于当前路径来说是唯一的，当前记录的前缀和，在回溯结束，回到本层时去除，保证其不影响其他分支的结果
     * @param node 树节点
     * @param prefixSumCount 前缀和Map
     * @param target 目标值
     * @param currSum 当前路径和
     * @return 满足题意的解
     */
    private int recursionPathSum(TreeNode node, Map<Integer, Integer> prefixSumCount, int target, int currSum) {
        // 1.递归终止条件
        if (node == null) {
            return 0;
        }
        // 2.本层要做的事情
        int res = 0;
        // 当前路径上的和
        currSum += node.val;

        //---核心代码
        // 看看root到当前节点这条路上是否存在节点前缀和加target为currSum的路径
        // 当前节点->root节点反推，有且仅有一条路径，如果此前有和为currSum-target,而当前的和又为currSum,两者的差就肯定为target了
        // currSum-target相当于找路径的起点，起点的sum+target=currSum，当前点到起点的距离就是target
        res += prefixSumCount.getOrDefault(currSum - target, 0);
        // 更新路径上当前节点前缀和的个数
        prefixSumCount.put(currSum, prefixSumCount.getOrDefault(currSum, 0) + 1);
        //---核心代码

        // 3.进入下一层
        res += recursionPathSum(node.left, prefixSumCount, target, currSum);
        res += recursionPathSum(node.right, prefixSumCount, target, currSum);

        // 4.回到本层，恢复状态，去除当前节点的前缀和数量
        prefixSumCount.put(currSum, prefixSumCount.get(currSum) - 1);
        return res;
    }
}

```

## 2020/7/3

#### [面试题 05.01. 插入](https://leetcode-cn.com/problems/insert-into-bits-lcci/)

难度简单10收藏分享切换为英文关注反馈

插入。给定两个32位的整数`N`与`M`，以及表示比特位置的`i`与`j`。编写一种方法，将`M`替换`N`，使得M从N的第i位开始，到第`j位结束。假定从`j`位到`i`位足以容纳`M`，也即若M = 10 011，那么j和i之间至少可容纳5个位。例如，不可能出现j = 3和i = 2的情况，因为第3位和第2位之间放不下M。位置不足以的高位填0；

**示例1:**

```
 输入：N = 10000000000, M = 10011, i = 2, j = 6
 输出：N = 10001001100
```

**示例2:**

```
 输入： N = 0, M = 11111, i = 0, j = 4
 输出：N = 11111
```

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：36.5 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    public int insertBits(int N, int M, int i, int j) {
        N&=~(((1<<(j-i+1))-1)<<i);
        N|=(M<<i);
        return N;
    }
}
```

#### [面试题 05.02. 二进制数转字符串](https://leetcode-cn.com/problems/bianry-number-to-string-lcci/)

###### 未作出

难度中等8收藏分享切换为英文关注反馈

二进制数转字符串。给定一个介于0和1之间的实数（如0.72），类型为double，打印它的二进制表达式。如果该数字不在0和1之间，**或者**无法精确地用32位以内的二进制表示，则打印“ERROR”。

**示例1:**

```
 输入：0.625
 输出："0.101"
```

**示例2:**

```
 输入：0.1
 输出："ERROR"
 提示：0.1无法被二进制准确表示
```

**提示：**

1. 32位包括输出中的"0."这两位。

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：37 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    public String printBin(double num) {
        if(num>=1||num<=0)return "ERROR";
        StringBuilder sb=new StringBuilder();
        sb.append("0.");
        while(num!=0){
            num*=2;
            if(num>=1){
                sb.append(1);
                num-=1;
            }else{
                sb.append(0);
            }
            if(sb.length()>32){
                return "ERROR";
            }
        }
        return sb.toString();
    }
}
```

#### [面试题 05.03. 翻转数位](https://leetcode-cn.com/problems/reverse-bits-lcci/)

###### 未作出

难度简单10收藏分享切换为英文关注反馈

给定一个32位整数 `num`，你可以将一个数位从0变为1。请编写一个程序，找出你能够获得的最长的一串1的长度。

**示例 1：**

```
输入: num = 1775(110111011112)
输出: 8
```

**示例 2：**

```
输入: num = 7(01112)
输出: 4
```

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：36.5 MB, 在所有 Java 提交中击败了100.00%的用户

```java
//数字应该向右移位，向左移位可能会越界，例如本题就有可能正负都有，int范围就变了
class Solution {
    public int reverseBits(int num) {
        int maxLen = 0, preLen = 0, curLen = 0;
        while (num>=0) {
            if ((num & 1) == 0) {
                curLen -= preLen;
                preLen = curLen + 1;
            }
            curLen++;
            maxLen = Math.max(maxLen, curLen);
            num >>= 1;
            if(num==0){
                break;
            }
        }
        maxLen=Math.max(curLen-preLen+1,maxLen);
        return maxLen;
    }
}
```

#### [面试题 05.04. 下一个数](https://leetcode-cn.com/problems/closed-number-lcci/)

###### 未作出

难度中等7收藏分享切换为英文关注反馈

下一个数。给定一个正整数，找出与其二进制表达式中1的个数相同且大小最接近的那两个数（一个略大，一个略小）。

**示例1:**

```
 输入：num = 2（或者0b10）
 输出：[4, 1] 或者（[0b100, 0b1]）
```

**示例2:**

```
 输入：num = 1
 输出：[2, -1]
```

**提示:**

1. `num`的范围在[1, 2147483647]之间；
2. 如果找不到前一个或者后一个满足条件的正数，那么输出 -1。

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：36.6 MB, 在所有 Java 提交中击败了100.00%的用户

```java
//暴力法，分别往2边搜索，找到符合条件的
class Solution {
    public int[] findClosedNumbers(int num) {
        int[] res=new int[]{-1,-1};
        int big=(1<<31)-1;
        int small=1;
        int count=find(num);
        for(int i=num+1;i<=big;i++){
            if(find(i)==count){
                res[0]=i;
                break;
            }
        }
        for(int i=num-1;i>=small;i--){
            if(find(i)==count){
                res[1]=i;
                break;
            }
        }
        return res;
    }
    private int find(int num){
        int count=0;
        while(num!=0){
            if((num&1)==1){
                count++;
            }
            num=num>>1;
        }
        return count;
    }
}
```

## 2020/7/4

#### [面试题 05.06. 整数转换](https://leetcode-cn.com/problems/convert-integer-lcci/)

###### 未作出（超时），思想对的，差一点

难度简单8收藏分享切换为英文关注反馈

整数转换。编写一个函数，确定需要改变几个位才能将整数A转成整数B。

**示例1:**

```
 输入：A = 29 （或者0b11101）, B = 15（或者0b01111）
 输出：2
```

**示例2:**

```
 输入：A = 1，B = 2
 输出：2
```

**提示:**

1. A，B范围在[-2147483648, 2147483647]之间

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：36.7 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    public int convertInteger(int A, int B) {
        int a=A^B,cnt=0;
        while(a!=0){
            a&=(a-1);
            cnt++;
        }
        return cnt;
    }
}
```

#### [面试题 05.07. 配对交换](https://leetcode-cn.com/problems/exchange-lcci/)

难度简单20收藏分享切换为英文关注反馈

配对交换。编写程序，交换某个整数的奇数位和偶数位，尽量使用较少的指令（也就是说，位0与位1交换，位2与位3交换，以此类推）。

**示例1:**

```
 输入：num = 2（或者0b10）
 输出 1 (或者 0b01)
```

**示例2:**

```
 输入：num = 3
 输出：3
```

**提示:**

1. `num`的范围在[0, 2^30 - 1]之间，不会发生整数溢出。

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：36.5 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    public int exchangeBits(int num) {
        int res=0,cnt=0;
        while(num!=0){
            int temp=num&1;
            if(cnt%2==0){
                res+=(temp<<(cnt+1));
            }else{
                res+=(temp<<(cnt-1));
            }
            num>>=1;
            cnt++;
        }
        return res;
    }
}
```

#### [面试题 05.08. 绘制直线](https://leetcode-cn.com/problems/draw-line-lcci/)

###### 未作出

难度中等3收藏分享切换为英文关注反馈

绘制直线。有个单色屏幕存储在一个一维数组中，使得32个连续像素可以存放在一个 int 里。屏幕宽度为`w`，且`w`可被32整除（即一个 int 不会分布在两行上），屏幕高度可由数组长度及屏幕宽度推算得出。请实现一个函数，绘制从点`(x1, y)`到点`(x2, y)`的水平线。

给出数组的长度 `length`，宽度 `w`（以比特为单位）、直线开始位置 `x1`（比特为单位）、直线结束位置 `x2`（比特为单位）、直线所在行数 `y`。返回绘制过后的数组。

**示例1:**

```
 输入：length = 1, w = 32, x1 = 30, x2 = 31, y = 0
 输出：[3]
 说明：在第0行的第30位到第31为画一条直线，屏幕表示为[0b000000000000000000000000000000011]
```

**示例2:**

```
 输入：length = 3, w = 96, x1 = 0, x2 = 95, y = 0
 输出：[-1, -1, -1]
```

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：39.7 MB, 在所有 Java 提交中击败了100.00%的用户

```
class Solution {
    public int[] drawLine(int length, int w, int x1, int x2, int y) {
        int[] ret = new int[length];
        // 注意根据所在行数计算偏移量
        int offset = y * w / 32;
        // 首位数字下标
        int head = x1 / 32 + offset;
        // 末位数字下标
        int rear = x2 / 32 + offset;
        // 把涉及到的数全部置 -1 也就是 0b11111111111111111111111111111111
        for (int i = head; i <= rear; i++)
            ret[i] = -1;
        // 调整首位数字无符号右移
        ret[head] = ret[head] & -1 >>> x1 % 32;
        // 调整末位数字有符号右移
        ret[rear] = ret[rear] & Integer.MIN_VALUE >> x2 % 32;
        return ret;
    }
}
```

#### [面试题 08.01. 三步问题](https://leetcode-cn.com/problems/three-steps-problem-lcci/)

难度简单14收藏分享切换为英文关注反馈

三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模1000000007。

**示例1:**

```
 输入：n = 3 
 输出：4
 说明: 有四种走法
```

**示例2:**

```
 输入：n = 5
 输出：13
```

**提示:**

1. n范围在[1, 1000000]之间

执行用时：40 ms, 在所有 Java 提交中击败了39.45%的用户

内存消耗：43.4 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    public int waysToStep(int n) {
        if(n<3)return n;
        int[] dp=new int[n];
        int a=1000000007;
        dp[0]=1;
        dp[1]=2;
        dp[2]=4;
        for(int i=3;i<n;i++){
            dp[i]=(((dp[i-1]+dp[i-2])%a)+dp[i-3])%a;
        }
        return dp[n-1];
    }
}
```

#### [面试题 08.02. 迷路的机器人](https://leetcode-cn.com/problems/robot-in-a-grid-lcci/)

难度中等23收藏分享切换为英文关注反馈

设想有个机器人坐在一个网格的左上角，网格 r 行 c 列。机器人只能向下或向右移动，但不能走到一些被禁止的网格（有障碍物）。设计一种算法，寻找机器人从左上角移动到右下角的路径。

![img](%E5%89%91%E6%8C%87offer%E9%A2%98%E8%A7%A3.assets/robot_maze.png)

网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。

返回一条可行的路径，路径由经过的网格的行号和列号组成。左上角为 0 行 0 列。如果没有可行的路径，返回空数组。

**示例 1:**

```
输入:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
输出: [[0,0],[0,1],[0,2],[1,2],[2,2]]
解释: 
输入中标粗的位置即为输出表示的路径，即
0行0列（左上角） -> 0行1列 -> 0行2列 -> 1行2列 -> 2行2列（右下角）
```

**说明：***r* 和 *c* 的值均不超过 100。

执行用时：2 ms, 在所有 Java 提交中击败了92.58%的用户

内存消耗：40.6 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    private int m;
private int n;
private int[][] grid;

/**
 *
 * @param row 表示当前考察位置的横座标
 * @param col 表示当前考察位置的纵座标
 * @param visited 标记数组，初始值皆为false，表示都还未经历，如果经历过，则设为true
 * @param pathList 保存总的路径用的数组
 * @return true or false
 */
private boolean dfs(int row, int col, boolean[][] visited, List<List<Integer>> pathList) {
    //异常情况：行坐标超出范围 或 列坐标超出范围 或 格子里是障碍物 或 访问过这个格子
    if (row >= m || col >= n || grid[row][col] == 1 || visited[row][col]) {
        return false;
    }

    pathList.add(Arrays.asList(row, col));
    //到最后一个格子了，也就是完成任务了
    if (row == m - 1 && col == n - 1) {
        return true;
    }
    //如果不是上边所列的异常情况，将当前格子标记为已经历过
    visited[row][col] = true;
    //如果右边格子或者下边格子是true的话，返回true。这里有一点需要注意，因为||的性质，前者，即右格为true的时候，就先不执行下格了。只有右格之后的路径难以为继的时候，才会来这里继续执行下格
    if (dfs(row, col + 1, visited, pathList) || dfs(row + 1, col, visited, pathList)) {
        return true;
    }
    //如果已经到了末路，即当前格子没有障碍，但右、下格子都是障碍的话，但还没有到达最后的格子，删掉数组pathList的最后一个元素。并返回false
    pathList.remove(pathList.size() - 1);
    return false;
}

public List<List<Integer>> pathWithObstacles(int[][] grid) {
    this.grid = grid;
    m = grid.length;
    n = grid[0].length;
    //保存路径用的数组
    List<List<Integer>> ansList = new ArrayList<>();
    //执行dfs函数
    dfs(0, 0, new boolean[m][n], ansList);
    return ansList;
}
}
```

## 2020/7/5

#### [面试题 08.03. 魔术索引](https://leetcode-cn.com/problems/magic-index-lcci/)

难度简单17收藏分享切换为英文关注反馈

魔术索引。 在数组`A[0...n-1]`中，有所谓的魔术索引，满足条件`A[i] = i`。给定一个有序整数数组，编写一种方法找出魔术索引，若有的话，在数组A中找出一个魔术索引，如果没有，则返回-1。若有多个魔术索引，返回索引值最小的一个。

**示例1:**

```
 输入：nums = [0, 2, 3, 4, 5]
 输出：0
 说明: 0下标的元素为0
```

**示例2:**

```
 输入：nums = [1, 1, 1]
 输出：1
```

**提示:**

1. nums长度在[1, 1000000]之间

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：40.9 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    public int findMagicIndex(int[] nums) {
        int n=nums.length;
        for(int i=0;i<n;i++){
            if(nums[i]==i){
                return i;
            }else if(nums[i]>i){
                i=nums[i]-1;
            }
        }
        return -1;
    }
}
```

#### [面试题 08.04. 幂集](https://leetcode-cn.com/problems/power-set-lcci/)

###### 未作出，list2.remove(list2.size()-1);//此处不记得ArrayList<>的方法意义了

难度中等21收藏分享切换为英文关注反馈

幂集。编写一种方法，返回某集合的所有子集。集合中**不包含重复的元素**。

说明：解集不能包含重复的子集。

**示例:**

```
 输入： nums = [1,2,3]
 输出：
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
```

执行用时：1 ms, 在所有 Java 提交中击败了99.32%的用户

内存消耗：40.3 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    private List<List<Integer>> list=new ArrayList<>();
    int n;
    public List<List<Integer>> subsets(int[] nums) {
        this.n=nums.length;
        list.add(new ArrayList<>());
        if(nums==null||n==0)return list;
        for(int i=1;i<=n;i++){
            
           
                dfs(nums,0,i,0,new ArrayList<>());
            
        }
        return list;
    }
    private void dfs(int[] nums,int index,int length,int count,List<Integer> list2){
        if(count==length){
            list.add(new ArrayList<>(list2));
            return;
        }
        for(int i=index;i<n;i++){
            list2.add(nums[i]);
            count++;
            dfs(nums,i+1,length,count,list2);
            count--;
            list2.remove(list2.size()-1);//此处不记得ArrayList<>的方法意义了
        }
        return;
    }
}
```

#### [面试题 08.05. 递归乘法](https://leetcode-cn.com/problems/recursive-mulitply-lcci/)

难度中等18收藏分享切换为英文关注反馈

递归乘法。 写一个递归函数，不使用 * 运算符， 实现两个正整数的相乘。可以使用加号、减号、位移，但要吝啬一些。

**示例1:**

```
 输入：A = 1, B = 10
 输出：10
```

**示例2:**

```
 输入：A = 3, B = 4
 输出：12
```

**提示:**

1. 保证乘法范围不会溢出

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：36.6 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    public int multiply(int A, int B) {
        if(A<B){
            int temp=A;
            A=B;
            B=temp;
        }
        int m=1;
        if(A<0){
            m*=(-1);
            A=(-A);
        }
        if(B<0){
            m*=(-1);
            B=(-B);
        }
        
        int res=0;
        int c=B;
        int offset=0;
        while(c!=0){
            if((c&1)==1){
                res+=(A<<offset);
            }
            offset++;
            c>>=1;
        }
        return m==1?res:-res;
    }
}
```

#### [面试题 08.06. 汉诺塔问题](https://leetcode-cn.com/problems/hanota-lcci/)

###### 未作出，对于递归和分治算法的认知不清晰

难度简单27收藏分享切换为英文关注反馈

在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:
(1) 每次只能移动一个盘子;
(2) 盘子只能从柱子顶端滑出移到下一根柱子;
(3) 盘子只能叠在比它大的盘子上。

请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。

你需要原地修改栈。

**示例1:**

```
 输入：A = [2, 1, 0], B = [], C = []
 输出：C = [2, 1, 0]
```

**示例2:**

```
 输入：A = [1, 0], B = [], C = []
 输出：C = [1, 0]
```

**提示:**

1. A中盘子的数目不大于14个。

**解题思路：递归与分治**
这是一道递归方法的经典题目，乍一想还挺难理清头绪的，我们不妨先从简单的入手。

假设 n = 1,只有一个盘子，很简单，直接把它从 A 中拿出来，移到 C 上；

如果 n = 2 呢？这时候我们就要借助 B 了，因为小盘子必须时刻都在大盘子上面，共需要 3 步。



如果 n > 2 呢？思路和上面是一样的，我们把 n 个盘子也看成两个部分，一部分有 1 个盘子，另一部分有 n - 1 个盘子。



你可能会问：“那 n - 1 个盘子是怎么从 A 移到 C 的呢？”

注意，当你在思考这个问题的时候，就将最初的 n 个盘子从 A 移到 C 的问题，转化成了将 n - 1 个盘子从 A 移到 C 的问题， 依次类推，直至转化成 1 个盘子的问题时，问题也就解决了。这就是分治的思想。

而实现分治思想的常用方法就是递归。不难发现，如果原问题可以分解成若干个与原问题结构相同但规模较小的子问题时，往往可以用递归的方法解决。具体解决办法如下：

n = 1 时，直接把盘子从 A 移到 C；
n > 1 时，
先把上面 n - 1 个盘子从 A 移到 B（子问题，递归）；
再将最大的盘子从 A 移到 C；
再将 B 上 n - 1 个盘子从 B 移到 C（子问题，递归）。

```java
class Solution {
    public void hanota(List<Integer> A, List<Integer> B, List<Integer> C) {
        int n=A.size();
        if(n==0) return;
        hanotaN(n,A,B,C);
    }
    public void hanotaN(int n,List<Integer> A, List<Integer> B, List<Integer> C){
        if(n==0)return;
        if(n==1){
            C.add(A.remove(A.size()-1));
        }else{
            hanotaN(n-1,A,C,B);
            C.add(A.remove(A.size()-1));
            hanotaN(n-1,B,A,C);
        }
    }
}
```

#### [面试题 08.07. 无重复字符串的排列组合](https://leetcode-cn.com/problems/permutation-i-lcci/)

难度中等19收藏分享切换为英文关注反馈

无重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合，字符串每个字符均不相同。

**示例1:**

```
 输入：S = "qwe"
 输出：["qwe", "qew", "wqe", "weq", "ewq", "eqw"]
```

**示例2:**

```
 输入：S = "ab"
 输出：["ab", "ba"]
```

**提示:**

1. 字符都是英文字母。
2. 字符串长度在[1, 9]之间。

执行用时：12 ms, 在所有 Java 提交中击败了76.85%的用户

内存消耗：47.7 MB, 在所有 Java 提交中击败了100.00%的用户

```
class Solution {
    ArrayList<String> list=new ArrayList<>();
    int n,count;
    boolean[] visited;
    public String[] permutation(String S) {
        this.n=S.length();
        StringBuilder sb=new StringBuilder();
        visited=new boolean[n];
        back(S,sb);
        return list.toArray(new String[count]);
    }
    private void back(String s,StringBuilder sb){
        if(sb.length()==n){
            list.add(sb.toString());
            count++;
            return;
        }
        
        for(int i=0;i<n;i++){
            if(!visited[i]){
                visited[i]=true;
                sb.append(s.charAt(i));
                back(s,sb);
                sb.deleteCharAt(sb.length()-1);
                visited[i]=false;
            }
        }
        return;
    }
}
```

#### [面试题 08.08. 有重复字符串的排列组合](https://leetcode-cn.com/problems/permutation-ii-lcci/)

难度中等19收藏分享切换为英文关注反馈

有重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合。

**示例1:**

```
 输入：S = "qqe"
 输出：["eqq","qeq","qqe"]
```

**示例2:**

```
 输入：S = "ab"
 输出：["ab", "ba"]
```

**提示:**

1. 字符都是英文字母。
2. 字符串长度在[1, 9]之间。

执行用时：1 ms, 在所有 Java 提交中击败了99.23%的用户

内存消耗：39.8 MB, 在所有 Java 提交中击败了100.00%的用户

```
class Solution {
    ArrayList<String> list=new ArrayList<>();
    int n,count;
    StringBuilder sb=new StringBuilder();
    char[] c;
    boolean[] visited;
    public String[] permutation(String S) {
        n=S.length();
        c=S.toCharArray();
        Arrays.sort(c);
        visited=new boolean[n];
        back(c);
        return list.toArray(new String[count]);
    }
    private void back(char[] c){
        if(sb.length()==n){
            list.add(sb.toString());
            count++;
            return;
        }
        for(int i=0;i<n;i++){
            if(visited[i]){
                continue;
            }
            if(i>=1&&c[i]==c[i-1]&&!visited[i-1]){
                continue;
            }
            if(!visited[i]){
                sb.append(c[i]);
                visited[i]=true;
                back(c);
                visited[i]=false;
                sb.deleteCharAt(sb.length()-1);
            }
        }
        return;
    }
}
```

#### [面试题 08.09. 括号](https://leetcode-cn.com/problems/bracket-lcci/)

###### 未作出

难度中等26收藏分享切换为英文关注反馈

括号。设计一种算法，打印n对括号的所有合法的（例如，开闭一一对应）组合。

说明：解集不能包含重复的子集。

例如，给出 n = 3，生成结果为：

```
[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]
```

执行用时：1 ms, 在所有 Java 提交中击败了91.29%的用户

内存消耗：40.4 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    List<String> list=new ArrayList<>();
    int n;
    public List<String> generateParenthesis(int n) {
        this.n=n;
        int left=0,right=0;
        dfs(left,right,new StringBuilder());
        return list;
    }
    private void dfs(int left,int right,StringBuilder sb){
        if(left==n&&right==n){
            list.add(new String(sb));
            return;
        }
        if(left<n) {
            sb.append("(");
            dfs(left+1,right,sb);
            sb.deleteCharAt(sb.length()-1);
        }
        if(right<left) {
            sb.append(")");
            dfs(left,right+1,sb);
            sb.deleteCharAt(sb.length()-1);
        }
    }
}
```

## 2020/7/6

#### [面试题 08.10. 颜色填充](https://leetcode-cn.com/problems/color-fill-lcci/)

难度简单11收藏分享切换为英文关注反馈

编写函数，实现许多图片编辑软件都支持的「颜色填充」功能。

待填充的图像用二维数组 `image` 表示，元素为初始颜色值。初始坐标点的横坐标为 `sr` 纵坐标为 `sc`。需要填充的新颜色为 `newColor` 。

「周围区域」是指颜色相同且在上、下、左、右四个方向上存在相连情况的若干元素。

请用新颜色填充初始坐标点的周围区域，并返回填充后的图像。

**示例：**

```
输入：
image = [[1,1,1],[1,1,0],[1,0,1]] 
sr = 1, sc = 1, newColor = 2
输出：[[2,2,2],[2,2,0],[2,0,1]]
解释: 
初始坐标点位于图像的正中间，坐标 (sr,sc)=(1,1) 。
初始坐标点周围区域上所有符合条件的像素点的颜色都被更改成 2 。
注意，右下角的像素没有更改为 2 ，因为它不属于初始坐标点的周围区域。
```

**提示：**

- `image` 和 `image[0]` 的长度均在范围 [1, 50] 内。
- 初始坐标点 `(sr,sc)` 满足 `0 <= sr < image.length` 和 `0 <= sc < image[0].length` 。
- `image[i][j]` 和 `newColor` 表示的颜色值在范围 `[0, 65535]` 内。

执行用时：1 ms, 在所有 Java 提交中击败了96.09%的用户

内存消耗：40.6 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    private int[][] dir=new int[][]{{0,1},{0,-1},{1,0},{-1,0}};
    int m,n;
    int target;
    int color;
    int[][] image;
    boolean[][] visited;
    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
        this.m=image.length;
        this.n=image[0].length;
        this.target=image[sr][sc];
        this.color=newColor;
        this.image=image;
        visited=new boolean[m][n];
        image[sr][sc]=color;
        visited[sr][sc]=true;
        dfs(sr,sc);
        return image;
    }
    private void dfs(int i,int j){

        for(int[] num:dir){
            int di=i+num[0];
            int dj=j+num[1];
            if(di>=0&&di<m&&dj>=0&&dj<n&&image[di][dj]==target&&!visited[di][dj]){
                image[di][dj]=color;
                visited[di][dj]=true;
                dfs(di,dj);
            }
        }
        return;
    }
}
```

#### [面试题 08.11. 硬币](https://leetcode-cn.com/problems/coin-lcci/)

###### 未作出（背包问题）

难度中等139收藏分享切换为英文关注反馈

硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)

**示例1:**

```java
 输入: n = 5
 输出：2
 解释: 有两种方式可以凑成总金额:
5=5
5=1+1+1+1+1
```

**示例2:**

```java
 输入: n = 10
 输出：4
 解释: 有四种方式可以凑成总金额:
10=10
10=5+5
10=5+1+1+1+1+1
10=1+1+1+1+1+1+1+1+1+1
```

**说明：**

注意:

你可以假设：

- 0 <= n (总金额) <= 1000000

执行用时：20 ms, 在所有 Java 提交中击败了90.52%的用户

内存消耗：43.9 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    public int waysToChange(int n) {
        int[] dp=new int[n+1];
        int[] coins=new int[]{1,5,10,25};
        dp[0]=1;
        for(int c:coins){
            for(int i=c;i<=n;i++){
                dp[i]=(dp[i]+dp[i-c]);
                if(dp[i]>=1000000007){
                    dp[i]=dp[i]%1000000007;
                }
            }
        }
        return dp[n];
    }
}
```

#### [面试题 08.12. 八皇后](https://leetcode-cn.com/problems/eight-queens-lcci/)

###### 未作出啊

难度困难26收藏分享切换为英文关注反馈

设计一种算法，打印 N 皇后在 N × N 棋盘上的各种摆法，其中每个皇后都不同行、不同列，也不在对角线上。这里的“对角线”指的是所有的对角线，不只是平分整个棋盘的那两条对角线。

**注意：**本题相对原题做了扩展

**示例:**

```java
 输入：4
 输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
 解释: 4 皇后问题存在如下两个不同的解法。
[
 [".Q..",  // 解法 1
  "...Q",
  "Q...",
  "..Q."],

 ["..Q.",  // 解法 2
  "Q...",
  "...Q",
  ".Q.."]
]
```

执行用时：2 ms, 在所有 Java 提交中击败了95.91%的用户

内存消耗：39.8 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    List<List<String>> list=new ArrayList<>();
    private boolean[] colb;
    private boolean[] visitedl;
    private boolean[] visitedr;
    int n;
    char[][] matrix;
    public List<List<String>> solveNQueens(int n) {
        this.n=n;
        matrix=new char[n][n];
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                matrix[i][j]='.';
            }
        }
        colb=new boolean[n];
        visitedl=new boolean[n+n-1];
        visitedr=new boolean[n+n-1];
        backTracing(0);
        return list;
    }
    private void backTracing(int h){
        if(h==n){
            List<String> list2=new ArrayList<>();
            for(int i=0;i<n;i++){
                list2.add(new String(matrix[i]));
            }
            list.add(list2);
            return;
        }
        for(int j=0;j<n;j++){
            if(!colb[j]&&!visitedl[n-1-h+j]&&!visitedr[h+j]){
                matrix[h][j]='Q';
                colb[j]=visitedl[n-1-h+j]=visitedr[h+j]=true;
                backTracing(h+1);
                colb[j]=visitedl[n-1-h+j]=visitedr[h+j]=false;
                matrix[h][j]='.';
            }
        }
        return;
    }
}
```

#### [面试题 08.13. 堆箱子](https://leetcode-cn.com/problems/pile-box-lcci/)

###### 未作出（回溯超时，未想到动态规划）

难度困难16收藏分享切换为英文关注反馈

堆箱子。给你一堆n个箱子，箱子宽 wi、深 di、高 hi。箱子不能翻转，将箱子堆起来时，下面箱子的宽度、高度和深度必须大于上面的箱子。实现一种方法，搭出最高的一堆箱子。箱堆的高度为每个箱子高度的总和。

输入使用数组`[wi, di, hi]`表示每个箱子。

**示例1:**

```
 输入：box = [[1, 1, 1], [2, 2, 2], [3, 3, 3]]
 输出：6
```

**示例2:**

```
 输入：box = [[1, 1, 1], [2, 3, 4], [2, 6, 7], [3, 4, 5]]
 输出：10
```

**提示:**

1. 箱子的数目不大于3000个。

执行用时：34 ms, 在所有 Java 提交中击败了59.25%的用户

内存消耗：39.5 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    public int pileBox(int[][] box) {
        Arrays.sort(box, (i, j) -> (i[0] != j[0] ? i[0] - j[0] : (i[1] != j[1] ? i[1] - j[1] : i[2] - j[2])));
        int n=box.length;
        int[] dp = new int[n];
        for(int i = 0; i < n; i++) {
            dp[i] = box[i][2];
            for(int j = 0; j < i; j++)
            if (box[i][0] > box[j][0] && box[i][1] > box[j][1] && box[i][2] > box[j][2]){
                dp[i] = Math.max(dp[i], box[i][2] + dp[j]);
            }
        }
        int max=0;
        for(int i=0;i<n;i++){
            if(dp[i]>max){
                max=dp[i];
            }
        }
        return max;
    }
}
```

## 2020/7/7

#### [面试题 08.14. 布尔运算](https://leetcode-cn.com/problems/boolean-evaluation-lcci/)

###### 未作出（超时，应该使用递归加记忆化，或者dp加记忆化）

难度中等21收藏分享切换为英文关注反馈

给定一个布尔表达式和一个期望的布尔结果 result，布尔表达式由 `0` (false)、`1` (true)、`&` (AND)、 `|` (OR) 和 `^` (XOR) 符号组成。实现一个函数，算出有几种可使该表达式得出 result 值的括号方法。

**示例 1:**

```java
输入: s = "1^0|0|1", result = 0

输出: 2
解释: 两种可能的括号方法是
1^(0|(0|1))
1^((0|0)|1)
```

**示例 2:**

```java
输入: s = "0&0&0&1^1|0", result = 1

输出: 10
```

**提示：**

- 运算符的数量不超过 19 个

执行用时：4 ms, 在所有 Java 提交中击败了84.12%的用户

内存消耗：39.4 MB, 在所有 Java 提交中击败了100.00%的用户

```java
//我写的
class Solution {
    int[][][] mem;//记忆化
    char[] cc;
    public int countEval(String s, int result) {
        int n=s.length();
        if(n==1){
            return s.charAt(0)-'0'==result?1:0;
        }
        mem=new int[n][n][2];
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                mem[i][j][0]=mem[i][j][1]=-1;
            }
        }
        cc=s.toCharArray();
        return help(0,n-1,result);
    }
    private int help(int l,int r,int result){
        if(r==l){
            return cc[l]-'0'==result?1:0;
        }
        if(mem[l][r][result]!=-1){
            return mem[l][r][result];
        }
        int temp=0;
        for(int i=l+1;i<r;i+=2){
            char c=cc[i];
            if(c=='&'){
                if(result==1){
                    temp+=help(l,i-1,1)*help(i+1,r,1);
                }else{
                    temp+=help(l,i-1,0)*help(i+1,r,1)+
                    help(l,i-1,1)*help(i+1,r,0)+
                    help(l,i-1,0)*help(i+1,r,0);
                }
            }else if(c=='|'){
                if(result==1){
                    temp+=help(l,i-1,0)*help(i+1,r,1)+
                    help(l,i-1,1)*help(i+1,r,0)+
                    help(l,i-1,1)*help(i+1,r,1);
                }else{
                    temp+=help(l,i-1,0)*help(i+1,r,0);
                }
            }else if(c=='^'){
                if(result==1){
                    temp+=help(l,i-1,1)*help(i+1,r,0)+
                    help(l,i-1,0)*help(i+1,r,1);
                }else{
                    temp+=help(l,i-1,1)*help(i+1,r,1)+
                    help(l,i-1,0)*help(i+1,r,0);
                }
            }
        }
        mem[l][r][result]=temp;
        return temp;
    }
}
```

执行用时：1 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：37.8 MB, 在所有 Java 提交中击败了100.00%的用户

```java
//别人写的
class Solution {
    public int countEval(String s, int result) {

        int len = s.length();
        if(len == 1){
            return s.charAt(0) - '0' == result ? 1 : 0;
        }
        int[][][] memo = new int[len][len][];
        int c = 0;
        char[] chs = s.toCharArray();
        //从分割符进行分割
        for(int i = 1; i < len; i += 2){
            int[] left = helper(chs, 0, i - 1, memo);
            int[] right = helper(chs, i + 1, len - 1, memo);
            int n1 = bool(0, 0, chs[i]);
            int n2 = bool(1, 1, chs[i]);
            int n3 = bool(0, 1, chs[i]);
            if(n1 == result){
                c += left[0] * right[0];
            }
            if(n2 == result){
                c += left[1] * right[1];
            }
            if(n3 == result){
                c += left[0] * right[1] + left[1] * right[0];
            }
        }
        return c;
    }
    /*
    最终 bool 运算只有两种结果 ，为 0 和 为 1
    那么我们直接统计左边结果为 0 的个数 和 结果为 1 的个数
    */
    private int[] helper(char[] chs, int l, int r, int[][][] memo){
        if(memo[l][r] != null){
            return memo[l][r];
        }
        int[] res = new int[2];

        memo[l][r] = res;

        if(l == r){
            if(chs[l] == '0'){
                res[0] = 1;
            }else{
                res[1] = 1;
            }
            return res;
        }
        for(int i = l + 1; i <= r; i += 2){
            int[] left = helper(chs, l, i - 1, memo);
            int[] right = helper(chs, i + 1, r, memo);
            int n1 = bool(0, 0, chs[i]);
            int n2 = bool(1, 1, chs[i]);
            int n3 = bool(0, 1, chs[i]);
            res[n1] += left[0] * right[0];
            res[n2] += left[1] * right[1];
            res[n3] += left[0] * right[1] + left[1] * right[0];
        }
        return res;
    }

    private int bool(int n1, int n2, char ch){
        switch(ch){
            case '&':
                return n1 & n2;
            case '|':
                return n1 | n2;
            case '^':
                return n1 ^ n2;
        }
        return n1 & n2;
    }
}
```

## 2020/7/7

#### [面试题 10.01. 合并排序的数组](https://leetcode-cn.com/problems/sorted-merge-lcci/)

难度简单57收藏分享切换为英文关注反馈

给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。

初始化 A 和 B 的元素数量分别为 *m* 和 *n*。

**示例:**

```
输入:
A = [1,2,3,0,0,0], m = 3
B = [2,5,6],       n = 3

输出: [1,2,2,3,5,6]
```

**说明:**

- `A.length == n + m`

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：39.8 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    public void merge(int[] A, int m, int[] B, int n) {
        int index=n+m-1;
        if(m==0){
            for(int i=0;i<n;i++){
                A[i]=B[i];
            }
        }else{
            int i=m-1,j=n-1;
            while(i>=0&&j>=0){
            if(A[i]>B[j]){
                A[index--]=A[i];
                A[i--]=0;
            }else{
                    A[index--]=B[j--];
                }
            }
            while(j>=0){
            A[index--]=B[j--];
            }
        }
    }
}
```

#### [面试题 10.02. 变位词组](https://leetcode-cn.com/problems/group-anagrams-lcci/)

###### 未作出（时间超出限制）

难度中等4收藏分享切换为英文关注反馈

编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串。

**注意：**本题相对原题稍作修改

**示例:**

```
输入: ["eat", "tea", "tan", "ate", "nat", "bat"],
输出:
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]
```

**说明：**

- 所有输入均为小写字母。
- 不考虑答案输出的顺序。

执行用时：10 ms, 在所有 Java 提交中击败了66.19%的用户

内存消耗：43 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        List<List<String>> res = new ArrayList<List<String>>();
        Map<String, List<String>> map = new HashMap<>();
        for(int i = 0; i < strs.length; i++){
            char[] arr = strs[i].toCharArray();
            Arrays.sort(arr);
            String s = new String(arr);
            if(!map.containsKey(s)){
                List<String> temp = new ArrayList<>();
                temp.add(strs[i]);
                map.put(s,temp);
            }else{
                map.get(s).add(strs[i]);
            }
        }

        for(String key: map.keySet()){
            res.add(map.get(key));
        }


        return res;
    }
}
```

#### [面试题 10.03. 搜索旋转数组](https://leetcode-cn.com/problems/search-rotate-array-lcci/)

###### 未作出(二分查找最左边等于某个值)

难度中等21收藏分享切换为英文关注反馈

搜索旋转数组。给定一个排序后的数组，包含n个整数，但这个数组已被旋转过很多次了，次数不详。请编写代码找出数组中的某个元素，假设数组元素原先是按升序排列的。若有多个相同元素，返回索引值最小的一个。

**示例1:**

```
 输入: arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 5
 输出: 8（元素5在该数组中的索引）
```

**示例2:**

```
 输入：arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 11
 输出：-1 （没有找到）
```

**提示:**

1. arr 长度范围在[1, 1000000]之间

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：40.8 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    public int search(int[] arr, int target) {
        int arrSize=arr.length;
       if(arrSize == 1) { 
        return arr[0] == target ? 0 : -1; 
    }

    int left = 0;
    int right = arrSize - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (arr[left] < arr[mid]) {
            if (arr[left] <= target && target <= arr[mid]) {
                right = mid;
            } else {
                left = mid + 1;
            }
        } else if (arr[left] > arr[mid]) {
            if ((arr[mid] < target) && (target <= arr[right]) && (arr[left] > arr[right])) {
                left = mid + 1;
            } else {
                right = mid;
            }
        } else if (arr[left] == arr[mid]) {  // 存在重复的元素
            if (arr[left] != target) {
                left++;
            } else {
                return left;       
            }
        }
    }
    return -1;
    }
}
```

#### [面试题 10.05. 稀疏数组搜索](https://leetcode-cn.com/problems/sparse-array-search-lcci/)

###### 未想到考察点（变异二分查找），自己暴力

难度简单14收藏分享切换为英文关注反馈

稀疏数组搜索。有个排好序的字符串数组，其中散布着一些空字符串，编写一种方法，找出给定字符串的位置。

**示例1:**

```
 输入: words = ["at", "", "", "", "ball", "", "", "car", "", "","dad", "", ""], s = "ta"
 输出：-1
 说明: 不存在返回-1。
```

**示例2:**

```
 输入：words = ["at", "", "", "", "ball", "", "", "car", "", "","dad", "", ""], s = "ball"
 输出：4
```

**提示:**

1. words的长度在[1, 1000000]之间

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：39.8 MB, 在所有 Java 提交中击败了100.00%的用户

```java
//此解法默认s不为"";
class Solution {
    public int findString(String[] words, String s) {
        int left = 0;
        int right = words.length - 1;
        int mid;
        while (left <= right){
            //如果最左边空字符串，跳过空串
            while (words[left].length() == 0&&left<=right){
                left ++;
            }
            //如果最右边空字符串，跳过空串
            while (right>=left&&words[right].length() == 0){
                right --;
            }
            mid = (left + right) / 2;
            //如果mid位置字符串为空串，mid--，直到不是空串
            while (mid >= 0 && words[mid].length() == 0){
                mid --;
            }
            if(words[mid].compareTo(s) == 0){
                return mid;
            }else if(words[mid].compareTo(s) > 0){
                right = mid - 1;
            }else {
                left = mid + 1;
            }
        }
        return -1;
    }
}
```

## 2020/7/9

#### [面试题 10.09. 排序矩阵查找](https://leetcode-cn.com/problems/sorted-matrix-search-lcci/)

难度中等7收藏分享切换为英文关注反馈

给定M×N矩阵，每一行、每一列都按升序排列，请编写代码找出某元素。

**示例:**

现有矩阵 matrix 如下：

```
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
```

给定 target = `5`，返回 `true`。

给定 target = `20`，返回 `false`。

执行用时：6 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：44.9 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if(matrix==null||matrix.length==0||matrix[0].length==0){
            return false;
        }
        int m=matrix.length,n=matrix[0].length;
        
        int i=0,j=n-1;
        while(i>=0&&i<m&&j>=0&&j<n){
            int temp=matrix[i][j];
            if(temp==target){
                return true;
            }else{
                if(temp<target){
                    i++;
                }else{
                    j--;
                }
            }
        }
        return false;
    }
}
```

#### [面试题 10.10. 数字流的秩](https://leetcode-cn.com/problems/rank-from-stream-lcci/)

###### 未作出(题目输入输出看不懂)

难度中等6收藏分享切换为英文关注反馈

假设你正在读取一串整数。每隔一段时间，你希望能找出数字 x 的秩(小于或等于 x 的值的个数)。请实现数据结构和算法来支持这些操作，也就是说：

实现 `track(int x)` 方法，每读入一个数字都会调用该方法；

实现 `getRankOfNumber(int x)` 方法，返回小于或等于 x 的值的个数。

**注意：**本题相对原题稍作改动

**示例:**

```
输入:
["StreamRank", "getRankOfNumber", "track", "getRankOfNumber"]
[[], [1], [0], [0]]
输出:
[null,0,null,1]
```

**提示：**

- `x <= 50000`
- `track` 和 `getRankOfNumber` 方法的调用次数均不超过 2000 次

执行用时：25 ms, 在所有 Java 提交中击败了56.33%的用户

内存消耗：40.2 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class StreamRank {
    private class Node{
        public Node left, right;
        int val;
        int nums;
        public Node(int val){
            this.val = val;
            nums = 1;
            left = null;
            right = null;
        }
    }
    private Node root;

    public StreamRank() {
        root = null;
    }
    
    public void track(int x) {
        root = add(root, x);
    }
    public Node add(Node node, int x) {
        if(node == null){
            return new Node(x);
        }
        if(x < node.val){
            node.left = add(node.left, x);
        }else if(x > node.val){
            node.right = add(node.right, x);
        }else{
            node.nums++;
        }
        return node;
    }
    
    public int getRankOfNumber(int x) {
        return find(root, x);
    }
    private int find(Node node, int x){
        if(node == null)
            return 0;
        int res = 0;
        if(node.val <= x){
            res += node.nums;
            res += find(node.right, x);
        }
        res += find(node.left, x);
        return res;
    }
}

/**
 * Your StreamRank object will be instantiated and called as such:
 * StreamRank obj = new StreamRank();
 * obj.track(x);
 * int param_2 = obj.getRankOfNumber(x);
 */
```

#### [面试题 10.11. 峰与谷](https://leetcode-cn.com/problems/peaks-and-valleys-lcci/)

###### 未最优化

难度中等10收藏分享切换为英文关注反馈

在一个整数数组中，“峰”是大于或等于相邻整数的元素，相应地，“谷”是小于或等于相邻整数的元素。例如，在数组{5, 8, 6, 2, 3, 4, 6}中，{8, 6}是峰， {5, 2}是谷。现在给定一个整数数组，将该数组按峰与谷的交替顺序排序。

**示例:**

```
输入: [5, 3, 1, 2, 3]
输出: [5, 1, 3, 2, 3]
```

**提示：**

- `nums.length <= 10000`

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：40.2 MB, 在所有 Java 提交中击败了100.00%的用户

```java
让我们假设“峰”在偶数位，“谷”在奇数位（倒过来也一样）
那么遍历一遍数组，有以下两个情况：
如果i为峰的位置，则判断当前位置是否小于前一个位置（前一个为谷），若小于，则交换，大于则不处理。即： if(nums[i]<nums[i-1]) swap(nums[i],nums[i-1])
如果i为谷的位置，则判断当前位置是否大于前一个位置（前一个为峰），若大于，则交换，大于则不处理。即： if(nums[i]>nums[i-1]) swap(nums[i],nums[i-1])
class Solution {
    public void wiggleSort(int[] nums) {
    for(int i = 1;i < nums.length; i++){
        if(((i&1) == 0 && nums[i] < nums[i-1])||((i&1) == 1 && nums[i] > nums[i-1])){
            int temp = nums[i];
            nums[i] = nums[i-1];
            nums[i-1] = temp;
        }
    }
}
}
```

#### [面试题 16.01. 交换数字](https://leetcode-cn.com/problems/swap-numbers-lcci/)

难度中等19收藏分享切换为英文关注反馈

编写一个函数，不用临时变量，直接交换`numbers = [a, b]`中`a`与`b`的值。

**示例：**

```
输入: numbers = [1,2]
输出: [2,1]
```

**提示：**

- `numbers.length == 2`

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：37.5 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    public int[] swapNumbers(int[] numbers) {
        numbers[1]=numbers[0]^numbers[1];
        numbers[0]=numbers[1]^numbers[0];
        numbers[1]=numbers[0]^numbers[1];
        return numbers;
    }
}
```

#### [面试题 16.02. 单词频率](https://leetcode-cn.com/problems/words-frequency-lcci/)

难度中等6收藏分享切换为英文关注反馈

设计一个方法，找出任意指定单词在一本书中的出现频率。

你的实现应该支持如下操作：

- `WordsFrequency(book)`构造函数，参数为字符串数组构成的一本书
- `get(word)`查询指定单词在书中出现的频率

**示例：**

```
WordsFrequency wordsFrequency = new WordsFrequency({"i", "have", "an", "apple", "he", "have", "a", "pen"});
wordsFrequency.get("you"); //返回0，"you"没有出现过
wordsFrequency.get("have"); //返回2，"have"出现2次
wordsFrequency.get("an"); //返回1
wordsFrequency.get("apple"); //返回1
wordsFrequency.get("pen"); //返回1
```

**提示：**

- `book[i]`中只包含小写字母
- `1 <= book.length <= 100000`
- `1 <= book[i].length <= 10`
- `get`函数的调用次数不会超过100000

执行用时：195 ms, 在所有 Java 提交中击败了51.58%的用户

内存消耗：89.8 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class WordsFrequency {
    Map<String,Integer> map=new HashMap<>();
    public WordsFrequency(String[] book) {
        
        for(String s:book){
           map.put(s,map.getOrDefault(s,0)+1);
        }
    }
    
    public int get(String word) {
        
        return map.getOrDefault(word,0);
    }
}

/**
 * Your WordsFrequency object will be instantiated and called as such:
 * WordsFrequency obj = new WordsFrequency(book);
 * int param_1 = obj.get(word);
 */
```

## 2020/7/10

#### [面试题 16.03. 交点](https://leetcode-cn.com/problems/intersection-lcci/)

###### 未作出（思路有的，但是代码太复杂，没写）

难度困难55收藏分享切换为英文关注反馈

给定两条线段（表示为起点`start = {X1, Y1}`和终点`end = {X2, Y2}`），如果它们有交点，请计算其交点，没有交点则返回空值。

要求浮点型误差不超过`10^-6`。若有多个交点（线段重叠）则返回 X 值最小的点，X 坐标相同则返回 Y 值最小的点。

**示例 1：**

```
输入：
line1 = {0, 0}, {1, 0}
line2 = {1, 1}, {0, -1}
输出： {0.5, 0}
```

**示例 2：**

```
输入：
line1 = {0, 0}, {3, 3}
line2 = {1, 1}, {2, 2}
输出： {1, 1}
```

**示例 3：**

```
输入：
line1 = {0, 0}, {1, 1}
line2 = {1, 0}, {2, 1}
输出： {}，两条线段没有交点
```

**提示：**

- 坐标绝对值不会超过 2^7
- 输入的坐标均是有效的二维坐标

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：38.7 MB, 在所有 Java 提交中击败了100.00%的用户

```java
//参见官方题解
class Solution {
  public double[] intersection(int[] start1, int[] end1, int[] start2, int[] end2) {
    int x1 = start1[0], y1 = start1[1];
    int x2 = end1[0], y2 = end1[1];
    int x3 = start2[0], y3 = start2[1];
    int x4 = end2[0], y4 = end2[1];

    double[] ans = new double[2];
    Arrays.fill(ans, Double.MAX_VALUE);
    // 判断两直线是否平行
    if ((y4-y3)*(x2-x1) == (y2-y1)*(x4-x3)) {
      // 判断两直线是否重叠
      if ((y2-y1)*(x3-x1) == (y3-y1)*(x2-x1)) {
        // 判断 (x3, y3) 是否在「线段」(x1, y1)~(x2, y2) 上
        if (isInside(x1, y1, x2, y2, x3, y3)) {
          updateRes(ans, x3, y3);
        }
        // 判断 (x4, y4) 是否在「线段」(x1, y1)~(x2, y2) 上
        if (isInside(x1, y1, x2, y2, x4, y4)) {
          updateRes(ans, (double)x4, (double)y4);
        }
        // 判断 (x1, y1) 是否在「线段」(x3, y3)~(x4, y4) 上
        if (isInside(x3, y3, x4, y4, x1, y1)) {
          updateRes(ans, (double)x1, (double)y1);
        }
        // 判断 (x2, y2) 是否在「线段」(x3, y3)~(x4, y4) 上
        if (isInside(x3, y3, x4, y4, x2, y2)) {
          updateRes(ans, (double)x2, (double)y2);
        }
      }
    } else {
      // 联立方程得到 t1 和 t2 的值
      double t1 = (double)(x3 * (y4 - y3) + y1 * (x4 - x3) - y3 * (x4 - x3) - x1 * (y4 - y3)) / ((x2 - x1) * (y4 - y3) - (x4 - x3) * (y2 - y1));
      double t2 = (double)(x1 * (y2 - y1) + y3 * (x2 - x1) - y1 * (x2 - x1) - x3 * (y2 - y1)) / ((x4 - x3) * (y2 - y1) - (x2 - x1) * (y4 - y3));
      // 判断 t1 和 t2 是否均在 [0, 1] 之间
      if (t1 >= 0.0 && t1 <= 1.0 && t2 >= 0.0 && t2 <= 1.0) {
        ans[0] = x1 + t1 * (x2 - x1);
        ans[1] = y1 + t1 * (y2 - y1);
      }
    }
    if (ans[0] == Double.MAX_VALUE) {
      return new double[0];
    }
    return ans;
  }

  // 判断 (x, y) 是否在「线段」(x1, y1)~(x2, y2) 上
  // 这里的前提是 (x, y) 一定在「直线」(x1, y1)~(x2, y2) 上
  private boolean isInside(int x1, int y1, int x2, int y2, int x, int y) {
    // 若与 x 轴平行，只需要判断 x 的部分
    // 若与 y 轴平行，只需要判断 y 的部分
    // 若为普通线段，则都要判断
    return (x1 == x2 || (Math.min(x1, x2) <= x && x <= Math.max(x1, x2)))
            && (y1 == y2 || (Math.min(y1, y2) <= y && y <= Math.max(y1, y2)));
  }

  private void updateRes(double[] ans, double x, double y) {
    if (x < ans[0] || (x == ans[0] && y < ans[1])) {
      ans[0] = x;
      ans[1] = y;
    }
  }
}
```

#### [面试题 16.04. 井字游戏](https://leetcode-cn.com/problems/tic-tac-toe-lcci/)

难度中等10收藏分享切换为英文关注反馈

设计一个算法，判断玩家是否赢了井字游戏。输入是一个 N x N 的数组棋盘，由字符" "，"X"和"O"组成，其中字符" "代表一个空位。

以下是井字游戏的规则：

- 玩家轮流将字符放入空位（" "）中。
- 第一个玩家总是放字符"O"，且第二个玩家总是放字符"X"。
- "X"和"O"只允许放置在空位中，不允许对已放有字符的位置进行填充。
- 当有N个相同（且非空）的字符填充任何行、列或对角线时，游戏结束，对应该字符的玩家获胜。
- 当所有位置非空时，也算为游戏结束。
- 如果游戏结束，玩家不允许再放置字符。

如果游戏存在获胜者，就返回该游戏的获胜者使用的字符（"X"或"O"）；如果游戏以平局结束，则返回 "Draw"；如果仍会有行动（游戏未结束），则返回 "Pending"。

**示例 1：**

```
输入： board = ["O X"," XO","X O"]
输出： "X"
```

**示例 2：**

```
输入： board = ["OOX","XXO","OXO"]
输出： "Draw"
解释： 没有玩家获胜且不存在空位
```

**示例 3：**

```
输入： board = ["OOX","XXO","OX "]
输出： "Pending"
解释： 没有玩家获胜且仍存在空位
```

**提示：**

- `1 <= board.length == board[i].length <= 100`
- 输入一定遵循井字棋规则

执行用时：4 ms, 在所有 Java 提交中击败了68.95%的用户

内存消耗：37.6 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    int n;
    boolean flags=true;;
    public String tictactoe(String[] board) {
        this.n=board.length;
        int count=0;
        boolean flag=true;
        for(int i=0;i<n;i++){
            count=0;
            flag=true;
            for(int j=0;j<n;j++){
                if(board[i].charAt(j)=='X'){
                    count++;
                }else if(board[i].charAt(j)==' '){
                    flag=false;
                    flags=false;
                    break;
                }
            }
            if(count==n){
                    return "X";
                }else if(count==0&&flag==true){
                    return "O";
                }
        }
        for(int i=0;i<n;i++){
            count=0;
            flag=true;
            for(int j=0;j<n;j++){
                if(board[j].charAt(i)=='X'){
                    count++;
                }else if(board[j].charAt(i)==' '){
                    flag=false;
                    flags=false;
                    break;
                }
            }
            if(count==n){
                    return "X";
                }else if(count==0&&flag==true){
                    return "O";
                }
        }
        count=0;
        int i=0,j=0;
        flag=true;
        while(i<n&&j<n){
            if(board[i].charAt(j)=='X'){
                count++;
            }else if(board[i].charAt(j)==' '){
                flag=false;
                flags=false;
                break;
            }
            i++;
            j++;
        }
        if(count==n){
                return "X";
        }else if(count==0&&flag==true){
                    return "O";
                }
        count=0;
        i=0;
        j=n-1;
        flag=true;
        while(i<n&&j>=0){
            if(board[i].charAt(j)=='X'){
                count++;
            }else if(board[i].charAt(j)==' '){
                flag=false;
                flags=false;
                break;
            }
            i++;
            j--;
        }
        if(count==n){
                return "X";
        }else if(count==0&&flag==true){
                    return "O";
                }
        if(flags==true){
            return "Draw";
        }else{
            return "Pending";
        }
        
    }
}
```

#### [面试题 16.05. 阶乘尾数](https://leetcode-cn.com/problems/factorial-zeros-lcci/)

难度简单15收藏分享切换为英文关注反馈

设计一个算法，算出 n 阶乘有多少个尾随零。

**示例 1:**

```
输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。
```

**示例 2:**

```
输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个零.
```

**说明:** 你算法的时间复杂度应为 *O*(log *n*) 。

执行用时：1 ms, 在所有 Java 提交中击败了99.48%的用户

内存消耗：36.5 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    public int trailingZeroes(int n) {
        int sum=0;
        int temp=n;
        while(temp>=5){
            temp=temp/5;
            sum+=temp;
        }
        return sum;
    }
}
```

#### [面试题 16.06. 最小差](https://leetcode-cn.com/problems/smallest-difference-lcci/)

###### 未作出（超时）

难度中等14收藏分享切换为英文关注反馈

给定两个整数数组`a`和`b`，计算具有最小差绝对值的一对数值（每个数组中取一个值），并返回该对数值的差

**示例：**

```
输入：{1, 3, 15, 11, 2}, {23, 127, 235, 19, 8}
输出： 3，即数值对(11, 8)
```

**提示：**

- `1 <= a.length, b.length <= 100000`
- `-2147483648 <= a[i], b[i] <= 2147483647`
- 正确结果在区间[-2147483648, 2147483647]内

执行用时：19 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：48.1 MB, 在所有 Java 提交中击败了100.00%的用户

```java
//双指针
class Solution {
    public int smallestDifference(int[] a, int[] b) {
    	long min =  Integer.MAX_VALUE;
    	int aIndex = 0;
    	int bIndex = 0;
        int m=a.length,n=b.length;
    	Arrays.sort(a);
    	Arrays.sort(b);
    	while(aIndex<m&&bIndex<n) {
    		if(min == 0)return 0;
    		if(a[aIndex]<b[bIndex]) {
    			while(aIndex<m &&a[aIndex]<b[bIndex]) {
        			aIndex++;
        		}
    			if(aIndex<m) {
    				min = Math.min(min, Math.abs((long)a[aIndex]-b[bIndex]));
            		
    			}
                min = Math.min(min, Math.abs((long)a[aIndex-1]-b[bIndex]));
        		
    		}else if(a[aIndex]>=b[bIndex]) {
    			while(bIndex<n &&a[aIndex]>b[bIndex]) {
        			bIndex++;
        		}
    			if(bIndex<n) {
    				min = Math.min(min, Math.abs((long)a[aIndex]-b[bIndex]));
    				
    			}
                min = Math.min(min, Math.abs((long)a[aIndex]-b[bIndex-1]));
    		}
    		
    		
    	}
    	return (int)min;
    }
}
```

#### [面试题 16.07. 最大数值](https://leetcode-cn.com/problems/maximum-lcci/)

###### 未作出（位运算）

难度简单41收藏分享切换为英文关注反馈

编写一个方法，找出两个数字`a`和`b`中最大的那一个。不得使用if-else或其他比较运算符。

**示例：**

```
输入： a = 1, b = 2
输出： 2
```

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：36.3 MB, 在所有 Java 提交中击败了100.00%的用户

```java
//位运算
//同号相减永不溢出，异号相比无脑选正。
//
class Solution {
    public int maximum(int a, int b) {
        //得到a,b的符号位
        int aFlag=a>>>31,bFlag=b>>>31;
        //得到是否异号
        int diff=aFlag^bFlag;
        //同号下处理与异号下处理
        int k=(diff^1)&((b-a)>>>31)|diff&bFlag;
        return a*k+b*(k^1);
    }
}
```

## 2020/7/11

#### [面试题 16.08. 整数的英语表示](https://leetcode-cn.com/problems/english-int-lcci/)

###### 未作出（我的思路太复杂，代码写不出来）

难度困难7收藏分享切换为英文关注反馈

给定一个整数，打印该整数的英文描述。

**示例 1:**

```
输入: 123
输出: "One Hundred Twenty Three"
```

**示例 2:**

```
输入: 12345
输出: "Twelve Thousand Three Hundred Forty Five"
```

**示例 3:**

```
输入: 1234567
输出: "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"
```

**示例 4:**

```
输入: 1234567891
输出: "One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One"
```

执行用时：6 ms, 在所有 Java 提交中击败了63.12%的用户

内存消耗：39.3 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    public String numberToWords(int num) {
        if(num == 0)
            return "Zero";
        List<String> res = new ArrayList<>();
        int hundred = 0;
        int thousand = 0;
        int million = 0;
        int billion = 0;
        if(num < 0){
            res.add("Negative");
            num = -num;    
        }
        if(num > 0){
            hundred = num % 1000;
            num /= 1000;
            if(num > 0){
                thousand = num % 1000;
                num /= 1000;
                if(num > 0){
                    million = num % 1000;
                    num /= 1000;
                    if(num > 0){
                        billion = num % 1000;
                    }
                }
            }
        }
        if(billion > 0){
            for(String str:change(billion))
                res.add(str);
            res.add("Billion");
        }
        if(million > 0){
            for(String str:change(million))
                res.add(str);
            res.add("Million");
        }
        if(thousand > 0){
            for(String str:change(thousand))
                res.add(str);
            res.add("Thousand");
        }
        if(hundred > 0){
            for(String str:change(hundred))
                res.add(str);
        }
        StringBuilder ans = new StringBuilder();
        for(String s:res){
            if(ans.length() == 0)
                ans.append(s);
            else{
                ans.append(" " + s);
            }
        }
        return ans.toString();
    }
    private LinkedList<String> change(int num){
        LinkedList<String> list = new LinkedList<>();
        int n = num % 100;
        if(0 < n && n < 20){
            list.addFirst(num0_19[n]);
        }else if(n >= 20){
            int m = n % 10;
            int mm = n / 10;
            if(m > 0)
                list.addFirst(num0_19[m]);
            list.addFirst(num0_90[mm]);
        }
        if(num >= 100){
            list.addFirst("Hundred");
            list.addFirst(num0_19[num / 100]);
        }
        return list;
    }
    private String[] num0_19 = new String[]{ "Zero","One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine","Ten","Eleven","Twelve","Thirteen","Fourteen","Fifteen","Sixteen","Seventeen","Eighteen","Nineteen" };
    private String[] num0_90 = new String[]{ "Zero","Ten","Twenty","Thirty", "Forty", "Fifty", "Sixty",  "Seventy", "Eighty", "Ninety" };
}

```

#### [面试题 16.09. 运算](https://leetcode-cn.com/problems/operations-lcci/)

###### 未作出（毫无思路，太难了）

难度中等7收藏分享切换为英文关注反馈

请实现整数数字的乘法、减法和除法运算，运算结果均为整数数字，程序中只允许使用加法运算符和逻辑运算符，允许程序中出现正负常数，不允许使用位运算。

你的实现应该支持如下操作：

- `Operations()` 构造函数
- `minus(a, b)` 减法，返回`a - b`
- `multiply(a, b)` 乘法，返回`a * b`
- `divide(a, b)` 除法，返回`a / b`

**示例：**

```
Operations operations = new Operations();
operations.minus(1, 2); //返回-1
operations.multiply(3, 4); //返回12
operations.divide(5, -2); //返回-2
```

**提示：**

- 你可以假设函数输入一定是有效的，例如不会出现除法分母为0的情况
- 单个用例的函数调用次数不会超过1000次

执行用时：19 ms, 在所有 Java 提交中击败了50.00%的用户

内存消耗：40 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Operations {

    // 用来获取-1
    int ne = Integer.MAX_VALUE + Integer.MAX_VALUE + 1;

    long[] neCache = new long[32];// 放置 -1,-2,-4,-8...
    long[] poCache = new long[32];// 放置 1,2,4,8...
    long[] cache = new long[32];// 存放乘数或除数的倍数，1*a,2*a,4*a,8*a...主要用于快速计算，不然容易超时
    long[] cache1 = new long[32];// 存放乘数或除数的倍数 负数-1*a,-2*a,-4*a,-8*a

    public Operations() {
        neCache[0] = ne;
        poCache[0] = 1;
        for (int i = 1; i < 32; ++i) {
            neCache[i] = neCache[i + ne] + neCache[i + ne];
            poCache[i] = poCache[i + ne] + poCache[i + ne];
        }
    }

    public int minus(int a, int b) {
        if (a == b) return 0;
        int index = 31;// 从最大值开始比较
        while (b != 0) {
            if (b > 0) {
                if (b >= poCache[index]) { // 如果b大于2的index次方，
                    b += neCache[index];// a与b同时减
                    a += neCache[index];
                } else {
                    index += ne;
                }
            } else { // b小于0时同理
                if (b <= neCache[index]) {
                    b += poCache[index];
                    a += poCache[index];
                } else {
                    index += ne;
                }
            }
        }
        return a;
    }

    public int multiply(int a, int b) {
        if (a == 0 || b == 0) return 0;
        if (a == 1) return b;
        if (b == 1) return a;
        if (a == ne) return minus(0, b);
        if (b == ne) return minus(0, a);
        int sign = (a > 0 && b > 0) || (a < 0 && b < 0) ? 1 : ne;
        // 把b变成正数
        if (b < 0) {
            b = minus(0, b);
        }

        cache[0] = a;
        for (int i = 1; i < 32; i++) {
            cache[i] = cache[i + ne] + cache[i + ne];
        }
        int index = 30; // 从31开始应该也是可以的
        int ret = 0;
        int retSign = a > 0 ? 1 : ne; // 记录返回值的符号
        while (b > 0) {
            if (b >= poCache[index]) {
                b += neCache[index];
                ret += cache[index];
                retSign = ret > 0 ? 1 : ne;// 记录返回值的符号
            } else {
                index += ne;
            }
        }
        // 根据初始值改变返回值的符号
        if ((sign < 0 && ret > 0) || (sign > 0 && ret < 0)) {
            ret = minus(0, ret);
        }
        // 结果溢出，返回值的符号会变成相反的
        if (retSign != (a > 0 ? 1 : ne)) {
            ret = minus(0, ret);
        }
        return ret;
    }

    public int divide(int a, int b) {
        if (a == 0) return 0;
        if (b == 1) return a;
        if (b == ne) return minus(0, a);
        int ret = 0;
        int sign = (a > 0 && b > 0) || (a < 0 && b < 0) ? 1 : ne;
        long nb = b;
        long pb = b;
        if (b < 0) {
            b = minus(0, b);
        } else {
            nb = minus(0, b);
        }
        if (a < 0) {
            a = minus(0, a);
        }
        cache[0] = b;
        cache1[0] = nb;
        int index = 1;
        for (; index < 32; ++index) {
            cache[index] = cache[index + ne] + cache[index + ne];
            cache1[index] = cache1[index + ne] + cache1[index + ne];
            if (cache1[index] >= a) {
                break; // 找到最大值就可以返回了，不用计算完
            }
        }
        if (index >= 32) index = 31;
        while (a >= b) {
            if (a >= cache[index]) {
                ret += poCache[index];// 注意这里是2的index次方的值
                a += cache1[index];
            } else {
                index += ne;
            }
        }
        if (sign < 0) {
            ret = minus(0, ret);
        }
        return ret;
    }
}
```

#### [面试题 16.10. 生存人数](https://leetcode-cn.com/problems/living-people-lcci/)

###### 只会暴力

难度中等12收藏分享切换为英文关注反馈

给定N个人的出生年份和死亡年份，第`i`个人的出生年份为`birth[i]`，死亡年份为`death[i]`，实现一个方法以计算生存人数最多的年份。

你可以**假设所有人都出生于1900年至2000年（含1900和2000）**之间。如果一个人在某一年的任意时期都处于生存状态，那么他们应该被纳入那一年的统计中。例如，生于1908年、死于1909年的人应当被列入1908年和1909年的计数。

如果有多个年份生存人数相同且均为最大值，输出其中最小的年份。

**示例：**

```
输入：
birth = {1900, 1901, 1950}
death = {1948, 1951, 2000}
输出： 1901
```

**提示：**

- `0 < birth.length == death.length <= 10000`
- `birth[i] <= death[i]`

执行用时：2 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：40.2 MB, 在所有 Java 提交中击败了100.00%的用户

```java
//得出需要计算的年份区间，把年份区间从小到大进行循环。如果当年有出生的则++，如果有去年有死亡的，则今年要--。最后根据前缀和得出每一年的存活人数，取出最多人存活的数组下坐标，

class Solution {
    public int maxAliveYear(int[] birth, int[] death) {
        int[] count = new int[102];
        int n=birth.length;
        for (int j = 0; j < n; j++) {
            count[birth[j] - 1900] += 1;
            count[death[j] - 1899] -= 1;
        }
        int maxIndex = 0;
        int maxCount = count[0];
        for (int i = 1; i < 102; i++) {
            count[i] = count[i] + count[i - 1];//preSum;
            if (count[i] > maxCount) {
                maxCount = count[i];
                maxIndex = i;
            }
        }
        return maxIndex + 1900;
    }
}
```

#### [面试题 16.11. 跳水板](https://leetcode-cn.com/problems/diving-board-lcci/)

难度简单60收藏分享切换为英文关注反馈

你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为`shorter`，长度较长的木板长度为`longer`。你必须正好使用`k`块木板。编写一个方法，生成跳水板所有可能的长度。

返回的长度需要从小到大排列。

**示例：**

```
输入：
shorter = 1
longer = 2
k = 3
输出： {3,4,5,6}
```

**提示：**

- 0 < shorter <= longer
- 0 <= k <= 100000

执行用时：2 ms, 在所有 Java 提交中击败了92.56%的用户

内存消耗：47.7 MB, 在所有 Java 提交中击败了100.00%的用户

```java
class Solution {
    public int[] divingBoard(int shorter, int longer, int k) {
        if(k==0)return new int[0];
        if(shorter==longer){
            return new int[]{shorter*k};
        }
        int[] res=new int[k+1];
        for(int i=k;i>=0;i--){
            res[k-i]=i*shorter+(k-i)*longer;
        }
        return res;
    }
}
```

## 2020/7/12

#### [面试题 16.13. 平分正方形](https://leetcode-cn.com/problems/bisect-squares-lcci/)

###### 未作出（想错了）

难度中等2收藏分享切换为英文关注反馈

给定两个正方形及一个二维平面。请找出将这两个正方形分割成两半的一条直线。假设正方形顶边和底边与 x 轴平行。

每个正方形的数据`square`包含3个数值，正方形的左下顶点坐标`[X,Y] = [square[0],square[1]]`，以及正方形的边长`square[2]`。所求直线穿过两个正方形会形成4个交点，请返回4个交点形成线段的两端点坐标（两个端点即为4个交点中距离最远的2个点，这2个点所连成的线段一定会穿过另外2个交点）。2个端点坐标`[X1,Y1]`和`[X2,Y2]`的返回格式为`{X1,Y1,X2,Y2}`，要求若`X1 != X2`，需保证`X1 < X2`，否则需保证`Y1 <= Y2`。

若同时有多条直线满足要求，则选择斜率最大的一条计算并返回（与Y轴平行的直线视为斜率无穷大）。

**示例：**

```
输入：
square1 = {-1, -1, 2}
square2 = {0, -1, 2}
输出： {-1,0,2,0}
解释： 直线 y = 0 能将两个正方形同时分为等面积的两部分，返回的两线段端点为[-1,0]和[2,0]
```

**提示：**

- `square.length == 3`
- `square[2] > 0`

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：38.4 MB, 在所有 Java 提交中击败了100.00%的用户

```java
//求过两个正方形中心的直线即可，如果两者中心重合，取垂直于x轴的直线。再根据斜率判断与正方形哪条边相交。
//斜率绝对值小于1， 与左右两边交;
class Solution {
    public double[] cutSquares(int[] square1, int[] square2) {
        double[] d_square1 = new double[]{(double) square1[0], (double) square1[1], (double) square1[2]};
        double[] d_square2 = new double[]{(double) square2[0], (double) square2[1], (double) square2[2]};
        double[] pos1 = {d_square1[0] + d_square1[2] / 2, d_square1[1] + d_square1[2] / 2};
        double[] pos2 = {d_square2[0] + d_square2[2] / 2, d_square2[1] + d_square2[2] / 2};

        if (pos1[0] == pos2[0]) {    //垂直
            double high = Math.max(d_square1[1] + d_square1[2], d_square2[1] + d_square2[2]);
            double low = Math.min(d_square1[1], d_square2[1]);
            return new double[]{pos1[0], low, pos1[0], high};
        }
        double k = (pos2[1] - pos1[1]) / (pos2[0] - pos1[0]);
        if (k >= 1 || k < -1) {
            double highy = Math.max(d_square1[1] + d_square1[2], d_square2[1] + d_square2[2]);       //上下开
            double lowy = Math.min(d_square1[1], d_square2[1]);

            double highx = pos1[0] - (pos1[1] - highy) / k;
            double lowx = pos1[0] - (pos1[1] - lowy) / k;
            return lowx < highx ? new double[]{lowx, lowy, highx, highy}
                : new double[]{highx, highy, lowx, lowy};
        }
        if (-1 <= k && k < 1) {
            double leftx = Math.min(d_square1[0], d_square2[0]);
            double rightx = Math.max(d_square1[0] + d_square1[2], d_square2[0] + d_square2[2]);      //左右开

            double lefty = pos1[1] - (pos1[0] - leftx) * k;
            double righty = pos1[1] - (pos1[0] - rightx) * k;
            return leftx < rightx ? new double[]{leftx, lefty, rightx, righty}
                : new double[]{rightx, righty, leftx, lefty};
        }
        return null;
    }
}
```

#### [面试题 16.14. 最佳直线](https://leetcode-cn.com/problems/best-line-lcci/)

###### 未作出

难度中等7收藏分享切换为英文关注反馈

给定一个二维平面及平面上的 N 个点列表`Points`，其中第`i`个点的坐标为`Points[i]=[Xi,Yi]`。请找出一条直线，其通过的点的数目最多。

设穿过最多点的直线所穿过的全部点编号从小到大排序的列表为`S`，你仅需返回`[S[0],S[1]]`作为答案，若有多条直线穿过了相同数量的点，则选择`S[0]`值较小的直线返回，`S[0]`相同则选择`S[1]`值较小的直线返回。

**示例：**

```
输入： [[0,0],[1,1],[1,0],[2,0]]
输出： [0,2]
解释： 所求直线穿过的3个点的编号为[0,2,3]
```

**提示：**

- `2 <= len(Points) <= 300`
- `len(Points[i]) = 2`

执行用时：28 ms, 在所有 Java 提交中击败了92.79%的用户

内存消耗：39.9 MB, 在所有 Java 提交中击败了100.00%的用户

```java
//O(N*2)
class Solution {
    int[][] points;
    //记录已搜寻以i为起点的2点之间的直线的斜率相同的可以链接的点的个数；每次i++后重置；
    HashMap<Double, Integer> lines = new HashMap<>();
    //记录已搜寻的斜率的前2个点的索引，int[2]；
    HashMap<Double, int[]> pairs = new HashMap<>();
    //以i为起点的水平线上的点的个数，points的长度，记录以i为起点的能连接的不同点个数（坐标不同与i），以i为起点的连线中和i点坐标一样样的个数；
    int horizontal_lines, points_num, count, duplicates;
    //索引结果，水平线的索引结果；
    int[] pair, horizontal_pair;

    public int[] bestLine(int[][] points) {
        this.points = points;
        points_num = points.length;
        if (points_num < 3) return new int[]{0, 1};
        int max_count = 1;
        int[] res = new int[0];
        for (int i = 0; i < points_num - 1; ++i) {
            int val = max_points_on_a_line_containing_point_i(i);
            if (max_count < val) {
                max_count = val;
                res = pair;
            }
        }
        return res;
    }

    public int max_points_on_a_line_containing_point_i(int i) {
        lines.clear();
        pairs.clear();
        horizontal_lines = 1;
        count = 1;
        duplicates = 0;
        pair = null;
        for (int j = i + 1; j < points_num; ++j)
            add_line(i, j);

        return count + duplicates;
    }

    public void add_line(int i, int j) {
        int x1 = points[i][0], y1 = points[i][1];
        int x2 = points[j][0], y2 = points[j][1];
        if ((x1 == x2) && (y1 == y2))
            ++duplicates;
        else if (y1 == y2) {
            if (horizontal_lines < 2)
                horizontal_pair = new int[]{i, j};
            if (count < ++horizontal_lines) {
                count = horizontal_lines;
                pair = horizontal_pair;
            }
        } else {
            double slope = 1.0 * (x1 - x2) / (y1 - y2) + 0.0;
            if (!pairs.containsKey(slope))
                pairs.put(slope, new int[]{i, j});
            lines.put(slope, lines.getOrDefault(slope, 1) + 1);
            if (count < lines.get(slope)) {
                count = lines.get(slope);
                pair = pairs.get(slope);
            }
        }
    }
}

```

## 2020/8/29

#### [面试题 16.15. 珠玑妙算](https://leetcode-cn.com/problems/master-mind-lcci/)

难度简单12收藏分享切换为英文关注反馈

珠玑妙算游戏（the game of master mind）的玩法如下。

计算机有4个槽，每个槽放一个球，颜色可能是红色（R）、黄色（Y）、绿色（G）或蓝色（B）。例如，计算机可能有RGGB 4种（槽1为红色，槽2、3为绿色，槽4为蓝色）。作为用户，你试图猜出颜色组合。打个比方，你可能会猜YRGB。要是猜对某个槽的颜色，则算一次“猜中”；要是只猜对颜色但槽位猜错了，则算一次“伪猜中”。注意，“猜中”不能算入“伪猜中”。

给定一种颜色组合`solution`和一个猜测`guess`，编写一个方法，返回猜中和伪猜中的次数`answer`，其中`answer[0]`为猜中的次数，`answer[1]`为伪猜中的次数。

**示例：**

```
输入： solution="RGBY",guess="GGRR"
输出： [1,1]
解释： 猜中1次，伪猜中1次。
```

**提示：**

- `len(solution) = len(guess) = 4`
- `solution`和`guess`仅包含`"R"`,`"G"`,`"B"`,`"Y"`这4种字符

执行用时：0 ms, 在所有 Java 提交中击败了100.00%的用户

内存消耗：37.6 MB, 在所有 Java 提交中击败了60.12%的用户

```java
class Solution {
        public int[] masterMind(String solution, String guess) {
        int hit = 0, udohit = 0; //猜中，伪猜中
        char[] sc = solution.toCharArray();
        char[] gc = guess.toCharArray();
        int[] dict = new int[128];
        for (int i = 0; i < gc.length; i++) {
            if (gc[i] == sc[i]) {
                gc[i] = '/'; //表示已经猜过了
                hit++;
            } else {
                dict[sc[i]]++;//剩余未猜中的建字典，类似set,用来做伪猜中.
            }
        }
        for (int i = 0; i < gc.length; i++) {
            if (dict[gc[i]] > 0) {
                dict[gc[i]]--; //伪猜中后，应猜字符数减少
                udohit++;
            }
        }
        return new int[]{hit, udohit};
    }

}

```

#### [面试题 16.16. 部分排序](https://leetcode-cn.com/problems/sub-sort-lcci/)

难度中等31

给定一个整数数组，编写一个函数，找出索引`m`和`n`，只要将索引区间`[m,n]`的元素排好序，整个数组就是有序的。注意：`n-m`尽量最小，也就是说，找出符合条件的最短序列。函数返回值为`[m,n]`，若不存在这样的`m`和`n`（例如整个数组是有序的），请返回`[-1,-1]`。

**示例：**

```
输入： [1,2,4,7,10,11,7,12,6,7,16,18,19]
输出： [3,9]
```

**提示：**

- `0 <= len(array) <= 1000000`



```

```

